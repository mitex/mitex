<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>

<title>Referát o vyhledávání v textu</title><meta http-equiv="Content-Type" content="text/html; charset=windows-1250"></head>



<body bgcolor="#ffffff" text="#000000">

<p align="right">Miroslav Beneš, 2001<br>Informatika I/2/31</p>
<center><h1>Vyhledávání v textu</h1></center>
<br><br><br><br>
<h2><a name="obsah">Obsah</a></h2>
<ol type="I">
 <li><a href="#uvod">Úvod</a>
 </li><li><a href="#zpoj">Základní pojmy</a>
 </li><li><a href="#alg">Algoritmy</a>
  <ol>
   <li><a href="#naiv">Naivní algoritmus</a>
   </li><li><a href="#kmp">Knuth-Morris-Prattùv algoritmus (KMP)</a>
   </li><li><a href="#bm">Boyer-Mooreùv algoritmus (BM)</a>
   </li><li><a href="#byg">Baeza-Yates-Gonnetùv algoritmus (BYG)</a>
   </li><li><a href="#qs">Quicksearch</a>
  </li></ol>
 </li><li><a href="#srov">Srovnání algoritmù</a>
 </li><li><a href="#zav">Závìr</a>
 </li><li><a href="#ref">Literatura</a>
</li></ol>

<br><br>
<h2><a name="uvod">I. Úvod</a></h2>

<p>
V dnešní dobì, kdy se vìtšina dokumentù (a u na úøadech nebo v bìnıch podmínkách) 
vede na poèítaèích, a tedy v elektronické podobì, je potøeba míti dostateènì silné
nástroje k tomu, aby se v danıch dokumentech vyhledal nìjakı text (slovo, vìta apod.)
v co nejkratším moném èase. Proto se øadu let vyvíjí rùzné algoritmy, které tento úkol
s odlišnımi úspìchy plní.<br>
Tyto algoritmy jsou bìnému uivateli poèítaèe schovány v jinıch vìtších celcích jako jsou
rùzné textové editory, kde je obèas nutné nìjaké to slovo v textu vyhledat (potamo zamìnit
za jiné). Dalším pøíkladem mohou bıt vyhledávací systémy v knihovnách, vyhledávání v 
databázích, všelijaké vyhledávací servery apod. Principy vyhledávání vzorkù v textu 
se také pouívají i v jinıch oborech ne v informatice, pøíkladem mùe bıt napøíklad
hledání "vzorkù" v DNA šroubovici.<br>
Z toho vyplıvá, e vyhledávání v textu je pomìrnì rozsáhlı problém o jeho uiteènosti
jistì není sporu. Proto je urèitì uiteèné uvést si nìjaké pøíklady algoritmù, které tento
problém øeší, popsat je a porovnat.
</p>
<p>
Algoritmy se mohou dìlit do nìkolika monıch kategorií podle toho za jakım úèelem se 
pouívají nebo podle svého pùvodu. Mùeme se tedy setkat s algoritmy, které vyhledávají
pouze jeden vzorek v daném textu, v jinıch pøípadech je mono vyhledávat mnoinu více
vzorkù. Rozdíl je také v tom, e nìkteré algoritmy naleznou pouze první vıskyt vzorku
v textu, jiné naleznou všechny vıskyty.
Existují algoritmy, které se inspirovaly i jinımi obory informatiky jako je napø. teorie
automatù.
</p>
<p>
V tomto èlánku bych se rád vìnoval zejména dvìma algoritmùm. Prvním je Knuth-Morris-Prattùv 
algoritmus (KMP), druhım je Boyer-Mooreùv algoritmus (BM). Spoleènım rysem obou je
skuteènost, e vyhledávají všechny vıskyty jednoho vzorku v daném textu. Na KMP se dá
nahlíet jako na upravenı koneènı (v tomto pøípadì vyhledávací) automat. BM se na druhou
stranu jeví jako naivní vyhledávací algoritmus (<a href="#naiv">viz dále</a>) se dvìmi
dùleitımi heuristikami.<br>
Pøedstavitelem skupiny algoritmù, které vyhledávají celou mnoinu vzorkù je napø.
algoritmus Aho-Corasickové, kterı je zaloen na poznatcích právì z teorie automatù.<br>
V dalším odstavci bych rád zmínil další dva zajímavé a relativnì nové algoritmy: 
Baeza-Yates-Gonnet, kterı je zaloen na vyhledávání pomocí bitovıch masek, a algoritmus
Quicksearch, jeho autorem je D.M. Sunday.
</p>
<p>
Nejprve si však zaveïme nìkolik dùleitıch pojmù a definic, které se budou hodit 
k pozdìjšímu popisu a zkoumání algoritmù.
</p>
<p align="right"><a href="#obsah">&gt;&gt;&gt;Obsah</a></p>

<br><br>
<h2><a name="zpoj">II. Základní pojmy</a></h2>
<p>
I pøesto, e vìtšina lidí v principu chápe, co vyhledávání v textu je, definujme si
tento pojem alespoò trochu pøesnìji a formálnìji.<br>
Nejprve si vysvìtlíme nìkteré základní pojmy potøebné pro popis daného problému. 
<strong>Abecedou &#931; </strong>rozumíme koneènou mnoinu znakù. Napøíklad 
&#931;<code>={0,1}</code> nebo &#931;<code>={a,b,...,z}</code>. Prvky této mnoiny se èasto
nazıvají znaky, písmena nebo symboly. <strong>Slovem</strong> v abecedì &#931; je mínìna
koneèná posloupnost znakù z této abecedy. Prázdnım slovem se rozumí posloupnost délky
0 a obvykle se znaèí <i>&#949;</i> (<i>&#949;</i> nepatøí do &#931;).<br>
Mnoina všech slov v abecedì &#931; se znaèí &#931;<sup>*</sup>. Na této mnoinì je definována
operace <strong>skládání (konkatenace)</strong>, která dvìma slovùm <code>x</code> a 
<code>y</code> délek <code>m</code> a <code>n</code> pøiøadí slovo <code>xy</code> délky
<code>m+n</code>. Tato operace je asociativní (to znamená, e <code>(xy)z</code> je to samé
slovo jako <code>x(yz)</code>) a pro více ne jednoprvkovou abecedu nekomutativní
(v pøípadì jednoprvkové abecedy: <code>aa</code>"=" <code>aa</code>, pokud &#931;<code>
={a}</code>; v pøípadì víceprvkové napø. <code>xy</code> není rovno <code>yx</code> pro 
<code>x, y</code> navzájem rùzná). Roli jednotkového prvku této operace hraje prázdné slovo
<i>&#949;</i>, tedy <code>x</code><i>&#949;</i><code>=</code><i>&#949;</i><code>x=x
</code> pro kadé <code>x</code> z <i>&#949;</i>. <br>
Nech <code>x</code> je prvkem &#931;<sup>*</sup>. Potom délkou slova <code>x</code> rozumíme
poèet znakù v <code>x</code>. Zapisujeme <code>|x|</code>. Tedy jak bylo poznamenáno 
<code>|</code><i>&#949;</i><code>|=0</code>.<br>
Øekneme, e slovo <code>x</code> z &#931;<sup>*</sup> je <strong>pøedponou (prefixem)</strong>
slova <code>y</code> z &#931;<sup>*</sup>, existuje-li takové slovo <code>u</code> z
&#931;<sup>*</sup>, e <code>xu=y</code>. Takové <code>u</code> zøejmì existuje nejvıše jedno
a je-li neprázdné, øíkáme, e <code>x</code> <strong>vlastní pøedpona</strong>. Obdobnì, 
øekneme, e slovo <code>x</code> z &#931;<sup>*</sup> je <strong>pøíponou (suffixem)</strong>
slova <code>y</code> z &#931;<sup>*</sup>, existuje-li takové slovo <code>v</code> z
&#931;<sup>*</sup>, e <code>vx=y</code>. Opìt takové <code>v</code> existuje nejvıše jedno
a je-li neprázdné, mluvíme o <strong>vlastní pøíponì</strong>.
Zøejmì platí, e <i>&#949;</i> je vlastní pøíponou a pøedponou kadého slova z 
&#931;<sup>*</sup>. Podobnì kadé slovo je svou jedinou nevlastní pøíponou i pøedponou.<br>
Pro pøíklad si uveïme, e slovo <code><strong>ab</strong></code> je pøedponou slova 
<code><strong>ab</strong>bdad</code> a to pøedponou vlastní. Zároveò je vlastní pøíponou slova
<code>abb<strong>ab</strong></code>.<br>
Pro další úèely si zaveïme ještì jeden jednoduchı pojem, <strong>prefix o <code>k</code> znacích.
</strong> Prefix vzorku <code>P[1..m]</code> o <code>k</code> znacích, tedy <code>P[1..k]</code>,
budeme znaèit <code>P<sub>k</sub></code>. Podobnì budeme mít tento pojem i pro prohledávanı text
(<code>T<sub>k</sub></code>).<br>
Nyní se vrame k formulaci problému vyhledávání v textu. Nech máme danou abecedu &#931; a 
tím i mnoinu &#931;<sup>*</sup>. Pøedpokládejme, e máme dány dva textové øetìzce 
(nejlepší je pøedstavit si je jako pole jednotlivıch znakù). Øetìzec 
<code>P = p<sub>1</sub>...p<sub>m</sub></code> (nebo jako pole znakù <code>P[1..m]</code>) 
budeme nazıvat <strong>vzorek</strong>. Jeho délka je <code>m</code>. Øetìzec 
<code>T = t<sub>1</sub>...t<sub>n</sub></code> (<code>T[1..n]</code>) bude prohledávanı text
délky <code>n</code>. Oba øetìzce jsou slova z &#931;<sup>*</sup>.<br>
Øíkáme, e vzorek <code>P</code> se v textu <code>T</code><strong> nachází s posunutím <code>s
</code></strong> (jinımi slovy øeèeno, nachází se v textu <code>T</code><strong> na pozici <code>
s+1</code></strong>), jestlie <code>0&lt;=s&lt;=n-m</code> a zároveò <code>T[s+1..s+m]=P[1..m]
</code> (pro všechna <code>j 1&lt;=j&lt;=m t<sub>s+j</sub>=p<sub>j</sub></code>). Pokud se 
vzorek <code>P</code> v prohledávaném textu <code>T</code> nachází nazıváme <code>s</code> 
<strong>platnım posunem </strong>. Jinak je tento posun <strong>neplatnı</strong>. Problém 
vyhledávání jednoho vzorku v textu lze tedy formulovat jako problém nalezení všech platnıch 
posunù, se kterımi se vzorek <code>P</code> nachází v textu <code>T</code>.
</p>
<img src="img/ObrII1.png" alt="Obr. 1" hspace="100">
<p>
Tento obrázek znázoròuje pøedchozí definici o vyhledávání v textu. Vzorek <code>P=bbcab</code>
se nachází v textu <code>T</code> s platnım posunem 4, neboli na 5. pozici.
</p>
<p align="right"><a href="#obsah">&gt;&gt;&gt;Obsah</a></p>

<br><br>
<h2><a name="alg">III. Algoritmy</a></h2>
<p>
Po vysvìtlení všech potøebnıch pojmù a formulaci daného problému se mùeme zaèít zabıvat 
jednotlivımi algoritmy. Nejprve se zlehka podíváme na naivní vyhledávací algoritmus a jeho
èasovou sloitost, aby se urèitım zpùsobem zdùvodnila potøeba lepších a efektivnìjších
vyhledávacích algoritmù. Poté probereme ji zmínìné dva algoritmy (Knuth-Morris-Pratt a
Boyer-Moore).
</p>
<h3><a name="naiv">1. Naivní algoritmus</a></h3>
<p>
Tento algoritmus je v podstatì vısledkem první myšlenky, která kadého napadne, kdy dostane
za úkol navrhnout algoritmus na vyhledávání v textu. Jednoduše øeèeno spoèívá v prozkoumání
všech moností (ne tedy doslova, ale v principu ano). Jak tomu u takovıch algoritmù bıvá,
jeho èasová sloitost není pøíliš dobrá.<br>
Myšlenka je jednoduchá. Budeme procházet zadanı text a na kadé pozici zkontrolujeme, zda
tu nezaèíná danı vzorek. Princip znázoròuje následující obrázek.
</p>
<img src="img/ObrIII2.png" alt="Obr. 2" hspace="70">
<p>
Jak je z obrázku vidno, vzorek se jakoby postupnì posouvá pod danım textem a na kadém místì
se kontroluje, zda se zde nenachází pøíslušnı vzorek. V tomto pøíkladu byl vzorek nalezen na
druhé pozici (s posunem 1, pøípad (b)). V ostatních pøípadech vdy nastala na urèitém místì 
vzorku kolize.<br>
Neefektivnost tohoto algoritmu spoèívá právì ve skuteènosti, e pokud narazím na neshodu, posunu
vzorek pouze o jedno místo doprava a zaènu porovnávat znovu, a to a do konce prohledávaného
textu. Tímto postupem se tedy nevyuívají informace, které byly získány v pøedchozím kroku.
Napøíklad u našeho obrázku po tom, co jsem našel vzorek v pøípadì (b), nemusím kontrolovat
pozici o jednu vpravo, ale mohu pøistoupit a k nákresu pod písmenem (d).<br>
Tyto informace, které závisí právì na zadaném vzorku se snaí vyuívat efektivnìjší 
algoritmy, které si zde ukáeme.<br>
Naivní algoritmus by v pseudokódu mohl vypadat asi následovnì:
</p>
<pre><code>
  (1)  n = length(T)
  (2)  m = length(P)
  (3)  for s = 1 to n-m+1
  (4)   if T[s..s+m-1] == P[1..m]
  (5)    then print("Vzorek se nachází na pozici", s)
</code></pre>
<p>
Nyní se kód rozeberme a podívejme se na èasovou sloitost algoritmu. První dvì øádky obstarávají
pouze uloení délky obou textovıch øetìzcù do promìnnıch <code>n</code> a <code>m</code>.
Posouvání vzorku pod textem zajišuje cyklus, kterı zaèíná na øádce (3). Provede se pøesnì
(n-m+1)-krát, co je poèet pozic, na kterıch se mùe vzorek vyskytovat. Øádka (5) jen informuje
o nalezení vzorku v textu. Pro urèení èasové sloitosti je klíèová øádka èíslo 4. Zde se
provádí porovnávání vzorku s danım textem. Tento pseudozápis mùe ve skuteènosti bıt while 
cyklus, kterı porovnává jednotlivé znaky dokud nenarazí na neshodu nebo na konec vzorku, v tomto
pøípadì se vykoná øádka (5). Je snadné nahlédnout, e v nejhorším pøípadì (to je e vdy projdu
všechny znaky ve vzorku) se while cyklus provede m-krát. Èasová sloitost v nejhorším pøípadì
je tedy <i>O((n-m+1)*m)</i>.
</p>
<p align="right"><a href="#obsah">&gt;&gt;&gt;Obsah</a></p>

<h3><a name="kmp">2. Knuth-Morris-Prattùv algoritmus (KMP)</a></h3>
<p>
Mezi prvními, kteøí si uvìdomili, e informace, které získává naivní algoritmus svım porovnáváním
znak po znaku, mohou bıt velmi cenné pro návrh efektivního algoritmu, byl právì Knuth se svımi
spoleèníky Morrisem a Prattem. Jejich nápad spoèíval v tom, e pokud se tyto informace vyuijí
správnım zpùsobem, mùe se vzorek nad prohledávanım textem posouvat i o více ne pouze o jeden
znak doprava. Tím se vıznamnì zkrátí doba potøebná k prohledání textu. Také je zbyteèné se
v prohledávaném textu vracet ke znakùm, které ji byly analyzovány tak jak to èiní naivní 
algoritmus. Toto vracení spoèívá ve skuteènosti, e pokud pøi porovnávání vzorku s danım textem
narazím na neshodu, vrátím se zpìt na zaèátek vzorku a ten posunu o jedno místo doprava. 
Tato èinnost je zøejmì zbyteèná, nebo já ji mám informaci o pøedchozích znacích, staèí ji
pouze dostateènì vyuít. Vracení se v textu mùe pøinést i další problém, kterı není na první 
pohled zøejmı. Pøi zpracovávání delšího textu, urèitì není tento text v pamìti poèítaèe celı.
Ze souboru se naèítá po kusech do nìjakého bufferu v pamìti, se kterım se poté pracuje.
Podívejme se na následující pøíklad.
</p>
<img src="img/ObrIII3.png" alt="Obr. 3" hspace="50">
<p>
Dejme tomu, e v takovémto textu hledáme vıskyt slova <strong>kapka</strong>. Dva øádky v obrázku
pøedstavují dva kusy textu tak, jak jsou naèteny do pamìti (bufferu). Naivní algoritmus
prochází prvním bufferem a na konci s podezøením, e se nachází uprostøed vzorku naète novı
kus textu a tento zahodí. Ovšem hned u prvního znaku zjistí neshodu a vzhledem ke své funkci mu
nezbude nic jiného ne se v textu vrátit. To ale pøedstavuje další pøístup na disk, nebo se musí
naèíst pøedchozí kus textu. Princip algoritmu KMP zajistí, e se nic takového nestane.
</p>
<img src="img/ObrIII4.png" alt="Obr. 4" hspace="50">
<p>
Tento obrázek je pøíkladem vıpoètu KMP algoritmu. Porovnávání vzorku s textem zaèíná jako obvykle
u prvního znaku zleva (vzorek je zarovnán s textem). Algoritmus postupuje dokud nenarazí na
neshodu na ètvrté pozici mezi znaky <strong>b</strong> a <strong>g</strong> (obrázek (a)).
Z pøedchozích znakù okamitì víme, e posun vzorku o jeden nebo dva znaky nemá vıznam. Posun 
o tøi znaky ale mùe splnit úèel. Tím se vzorek zarovná s textem nad znakem, kde nastala neshoda.
Odtud dále mùe pokraèovat porovnávání. Jak vidno na této pozici se hned první písmeno vzorku
neshoduje se znakem v textu (obrázek (b)), vzorek se poté posune o jedno místo doprava.
Velikost takového posunu (o tøi v prvním nebo o jeden znak v dalších pøípadech) závisí pouze
na charakteru a formì kadého vzorku. Posun je nezávislı na prohledávaném textu. Jeho velikost
urèuje tzv. <strong>prefixová funkce</strong>.<br>
Díky prefixové funkci si pøed spuštìním vlastního vyhledávacího algoritmu pøedpoètu hodnoty
posunù pro jednotlivé pozice ve vzorku do nìjaké tabulky. Mnoho efektivních vyhledávacích 
algoritmù pouívá podobné pøedpoèítané tabulky, které se pozdìji v prùbìhu vyhledávání pouívají.
Tedy jak je patrné algoritmus KMP bude mít dvì fáze. V první fázi si z daného vzorku vypoèítáme
potøebné hodnoty posunù. Druhá fáze bude uskuteèòovat vlastní vyhledávání.<br>
Nejdøíve se tedy vìnujme první fázi a prefixové funkci. Tato funkce vyjadøuje chování vzorku
vzhledem k posunùm k sobì samému. Uveïme si ještì jeden pøíklad.
</p>
<img src="img/ObrIII5.png" alt="Obr. 5" hspace="50" vspace="10">
<p>
Na obrázku (a) vidíme, e pøi takovémto zarovnání (s posunem <code>s</code>), se prvních pìt
písmen vzorku shoduje s pìti písmeny v textu (<code>q=5</code>), pøièem na znaku šestém došlo
k neshodì. Z informace, e pìt písmen se shodovalo, mùeme okamitì vyvodit, které to byly, 
nebo je to prvních pìt písmen ve vzorku, a také mùeme zjistit pøíslušnı posun. Je moné urèit
posuny, o kterıch ji teï mohu prohlásit, e jsou neplatné, a tím je v budoucnu pøeskoèit. Zde
je na první pohled jasné, e posun o jedno políèko doprava (tedy posun <code>s+1</code>) je
neplatnı, nebo první písmeno ve vzorku (<strong>a</strong>) by bylo zarovnáno k písmenu v textu,
o kterém ji máme informaci, e se shodovalo s druhım písmenem ve vzorku (<strong>b</strong>).
Posun <code>s+2</code> na obrázku (b) naopak dává jistou nadìji, e by vzorek mohl bıt nalezen
na tomto místì, nebo tøi znaky se shodují.<br>
K navrení kódu, kterı vypoèítá dané hodnoty je tedy tøeba vyøešit následující problém. Nech
máme dány znaky <code>P[1..q]</code>, o kterıch víme, e se shodují s tìmito znaky v textu
<code>T[s+1..s+q]</code> (v našem pøíkladu je to slovo <strong>ababa</strong>, na obrázku 
vybarvená políèka). Jakı je nejmenší posun <code>s'&gt;s</code> takovı, aby platilo
<code>P[1..k]=T[s'+1..s'+k]</code>, pøièem <code>s'+k=s+q</code>. Slovy øeèeno to znamená pøesnì
to, o co se snaíme. Jak moc mùeme vzorek posunout doprava tak, aby se pøedpona vzorku kratší 
ne poèet znakù (<strong>aba</strong>ba), které se pøedtím shodovaly (ababa, tedy 5), shodovala
s pøíponou slova v textu (ab<strong>aba</strong>), které bylo støedem shody (ababa). Pokud taková
pøedpona není (<code>k=0</code>) posuneme vzorek o poèet znakù, které se shodovaly 
(<code>q=5</code>).<br>
Tedy posun <code>s'</code> je nejmenší takovı, e je vìtší ne <code>s</code> a není nezbytnì
neplatnı. Jak bylo øeèeno v nejlepším pøípadì je novı posun <code>s'</code> roven 
<code>s+q</code>. V kadém pøípadì ji nemusíme porovnávat prvních <code>k</code> znakù vzorku,
nebo jejich shodu v textem máme zaruèenou.<br>
Tyto informace se dají spoèítat porovnáváním vzorku se sebou samım, jak je hrubì naznaèeno
na obrázku (c). Víme, e <code>T[s'+1..s'+k]</code> (ab<strong>aba</strong>) je èást známého
textu, a tedy to musí bıt pøípona jisté èásti <code>P</code>, která také byla prozkoumána.
Je to pøesnì pøípona <code>P<sub>q</sub></code>. Nyní mùeme pøesnì formulovat poadavek na 
posun <code>s'</code> a to pro kadou pozici ve vzorku.<br>
Nech mám vzorek <code>P[1..m]</code>, potom prefixová funkce (udává posuny <code>s'</code>)
vypadá následovnì:
</p>
<pre><code>
  &#960; : {1,...,m} -&gt; {0,...,m-1}, taková e

    &#960;[q]= max{k: k&lt;q and P<sub>k</sub> je pøíponou P<sub>q</sub>}.
</code></pre>
<p>
Pro prefixovou funkci dále platí, e pro kadé <code>q</code> z {1,...,m} je 
&#960;[<code>q</code>]&lt;<code>q</code>.<br><br>
<i>Pozn. &#960;[q] tedy pøedstavuje délku nejdelší pøedpony <code>P</code>, která je pøíponou 
<code>P<sub>q</sub></code>.</i>
</p>
<p>
Nyní se podívejme, jak bude algoritmus KMP fungovat jako celek. Tedy první fází je vıpoèet 
prefixové funkce, kterı jsme si v principu popsali. Následuje fáze druhá, vyhledávání.
Princip je velice jednoduchı. Na zaèátku zarovnám vzorek vùèi textu a zaènu porovnávat. Pokud
narazím na neshodu, podívám se do tabulky prefixové funkce s indexem, kterı odpovídá pozici ve
vzorku, kde došlo k neshodì. S tabulky zjistím èíslo, které udává znak vzorku (èíslo urèuje
jeho pozici ve vzorku) kterı se, kdy pøíslušnì zarovnám vzorek k textu, bude nacházet pøesnì
nad znakem v textu, kterı byl pøíèinou neshody (vzorek se tedy posune doprava). Vzorek budu tímto
zpùsobem posouvat doprava dokud nenarazím na jeho zaèátek nebo nebudu moci pokraèovat od dané
pozice dalším porovnáváním. Takto pokraèuji dokud nenarazím na konec textu. Pokud vzorek v textu 
najdu, oznámím to a pokraèuji dále (dá se toti uvaovat, e u posledního znaku ve vzorku došlo 
k neshodì).<br>
Nyní si ji mùeme uvést zápis algoritmu v pseudokódu (na vstupu je text <code>T</code> a vzorek
<code>P</code>).
</p>
<pre><code>
  (1)  n = length(T)
  (2)  m = length(P)
  (3)  &#960; = Prefix_func(P)
  (4)  q = 0
  (5)  for i = 1 to n
  (6)    while (q &gt; 0 &amp;&amp; P[q+1] != T[i]) q = &#960;[q]
  (7)    if P[q+1] == T[i] then q = q+1
  (8)    if q = m then 
  (9)      print("Vzorek se nachází na pozici", i-m+1)
 (10)      q = &#960;[q]

Prefix_func(P)
  (1)  m = length(P)
  (2)  &#960;[1] = 0
  (3)  k = 0
  (4)  for q = 2 to m
  (5)    while (k &gt; 0 &amp;&amp; P[k+1] != P[q]) k = &#960;[k]
  (6)    if P[k+1] == P[q] then k = k+1
  (7)    &#960;[q] = k
  (8)  return &#960;
</code></pre>
<p>
Nyní si urèíme èasovou sloitost algoritmu. Nejprve vıpoèet prefixové funkce. Základem je,
e vnitøní while cyklus se provede nejvıše tolikrát jako cyklus vnìjší. Platí toti, e kadım
prùchodem vnitøním cyklem se promìnná <code>k</code> sníí, nebo
&#960;[<code>k</code>]&lt;<code>k</code>. Souèasnì se promìnná <code>k</code> mùe zvıšit nejvıše
jednou v kadém kroku vnìjšího cyklu (díky øádce (6)). Z toho evidentnì plyne, e poèet prùbìhù
vnitøním cyklem je menší roven poètu krokù vnìjšího cyklu. Odtud ji plyne, e èasová sloitost
vıpoètu prefixové funkce je <i>O(m)</i>.<br>
Obdobnou úvahou dojdeme k tomu, e èasová sloitost vyhledávací fáze je <i>O(n)</i>. Èasová 
sloitost celého algoritmu je tedy <i>O(m+n)</i>, co je vıraznì lepší ne u naivního algoritmu.
</p>
<p>
V úvodu celého referátu bylo øeèeno, e KMP algoritmus do jisté míry souvisí s koneènımi 
automaty. Jak? Je to velice jednoduché. Pøedpokládejme, e máme vzorek <code>P</code> délky
<code>m</code>. Definujeme si tedy koneènı automat, kterı bude mít <code>m+1</code> stavù. 
Pøechody mezi jednotlivımi stavy budou postupnì urèené jednotlivımi písmeny vzorku. Tedy napø.
pøechod mezi nultım a prvním stavem bude podle písmena <code>p<sub>1</sub></code>, pøechod mezi
prvním a druhım stavem podle <code>p<sub>2</sub></code> atd. Zbylé pøechody (tedy jakési chybové)
bude urèovat právì prefixová funkce. Vstupním stavem bude stav 0 a vıstupním stav <code>m</code>.
Samotné vyhledávání bude realizováno jako práce takového automatu se vstupem, kterı odpovídá
zadanámu textu. Je zde pouze rozdíl v tom, e pokud se pomocí prefixové funkce vrátím do 
nìkterého pøedešlého stavu, okamitì zkusím pøes to samé písmeno (které vlastnì zpùsobilo 
neshodu) pøejít do následujícího stavu, jinak se vracím dále.<br>
Uveïme si pøíklad.
</p>
<img src="img/ObrIII6.png" alt="Obr. 6" hspace="70" vspace="10">
<p>
Na obrázku je koneènı automat pro vzorek <strong>perpetrate</strong>. Nyní si ukáeme, jak bude
vypadat vıpoèet automatu pro dvì rùzná slova. Vıpoèet je znázornìn jako posloupnost stavù, mezi
kterımi jsou písmena, pøes která se mezi stavy pøechází.<br><br>
(a) budeme prohledávat text <strong>perperpetrate</strong>:     
0<sup>p</sup>1<sup>e</sup>2<sup>r</sup>3<sup>p</sup>4<sup>e</sup>5<sup>r</sup>2<sup>r</sup>
3<sup>p</sup>4<sup>e</sup>5<sup>t</sup>6<sup>r</sup>7<sup>a</sup>8<sup>t</sup>9<sup>e</sup>10
<br>
(b) nyní to bude text <strong>perpespetrate</strong>:     
0<sup>p</sup>1<sup>e</sup>2<sup>r</sup>3<sup>p</sup>4<sup>e</sup>5<sup>s</sup>2<sup>s</sup>
0<sup>p</sup>1<sup>e</sup>2<sup>r</sup>3<sup>p</sup>4<sup>e</sup>5<sup>t</sup>6<sup>r</sup>
7<sup>a</sup>8<sup>t</sup>9<sup>e</sup>10
</p>
<p align="right"><a href="#obsah">&gt;&gt;&gt;Obsah</a></p>
<br><br>

<a name="bm"><h3>3. Boyer-Mooreùv algoritmus (BM)</h3></a>
<p>
V této kapitole si pøedvedeme další chytrı a efektivní algoritmus jeho autory jsou S. Boyer a
J. Strother Moore. Jak bylo øeèeno v úvodu, tento algoritmus se pøíliš zásadnì neliší od 
naivního algoritmu, kterı jsme si ukázali. Je zde pouze nìkolik odlišností. Abychom si je
ukázali, pøedvedeme si ihned, jak Boyer-Mooreùv algoritmus vypadá. Na vstupu je text 
<code>T</code>, vzorek <code>P</code> a abeceda &#931;.
</p>
<pre><code>
  (1)  n = length(T)
  (2)  m = length(P)
  (3)  &#955; = Last_Occur_func(P,m,&#931;)
  (4)  &#947; = Good_suff_func(P,m)
  (5)  s = 0
  (6)  while (s &lt;= n-m)
  (7)    j = m
  (8)    while (j &gt; 0 &amp;&amp; P[j] == T[s+j]) j = j-1
  (9)    if j == 0 
 (10)      then print("Vzorek se nachází na pozici", s+1)
 (11)           s = s+&#947;[0]
 (12)      else s = s+max(&#947;[j], j-&#955;[T[s+j]])
</code></pre>
<p>
V èem se tedy tento algoritmus podobá a v èem se liší od naivního algoritmu? Podobnost je jak
ve struktuøe (co zas tak podstatné není) tak ve skuteènosti, e se vzorek opìt porovnává
s danım textem a v pøípadì neshody se vzorek posune doprava. Odlišnosti jsou v tom, e
vzorek se s textem porovnává zprava doleva, tedy odzadu (u naivního algoritmu se porovnávání
provádí zleva doprava). Pokud narazím na zaèátek vzorku, je jasné e jsem v textu našel jeho 
vıskyt. Zde je další rozdíl, nebo pøi takovém nálezu neposunu vzorek o jedno místo doprava,
ale o nìjakou hodnotu &#947;[0]. Pokud narazím na neshodu opìt posunu vzorek, ale posun nemusí
mít nutnì velikost jedna jako u naivního algoritmu. Ve skuteènosti je tento posun mnohdy mnohem
vìtší. Další odlišností je, e v pøípadì naivního algoritmu (a vlastnì i v pøípadì 
Knuth-Morris-Prattova algoritmu) se zpracoval kadı znak prohledávaného textu aspoò jednou 
(u naivního algoritmu i mnohokrát). U Boyer-Mooreova algoritmu se díky tomu, e vzorek procházím
od konce, a díky tomu, e vzorek v pøípadì neshody posunu mnohdy o více ne jedno písmeno 
doprava, na nìkteré znaky v prohledávaném textu vùbec nedostane (pøeskoèí se).<br>
Aby se tohoto úspìchu dosáhlo, pouívá algoritmus dvì heuristiky (v kódu jsou reprezentovány
zatím záhadnımi symboly &#947; a &#955;). Jeliko jde o heuristiky dá se oèekávat, e
se èasová sloitost v nejhorším pøípadì oproti naivnímu algoritmu pøíliš nezlepší. Naštìstí
jsou tyto heuristiky tak efektivní a úspìšné, e v bìné praxi dosahují velmi dobrıch vısledkù.
Jak bylo øeèeno vıše, spousta znakù v textu se díky tìmto heuristikám mùe jednoduše pøeskoèit
ani by byly nìjakım zpùsobem zpracovány. Na následujícím obrázku si ukáeme, jaká ja základní
myšlenka obou heuristik. Jen pro zajímavost v angliètinì se nazıvají "bad-character heuristic"
(tedy nìco jako heuristika špatného znaku. Z toho se dá odvodit, e heuristika bude nìjakım
zpùsobem souviset se znakem, kterı v textu zpùsobil neshodu.) a "good-suffix heuristic" 
(tomu v èeštinì odpovídá asi heuristika dobré pøípony. Opìt je zjevné, e bude souviset 
s pøíponami vzorku).
</p>
<img src="img/ObrIII7.png" alt="Obr. 7" hspace="80" vspace="10">
<p>
Na obrázku (a) vidíme, e hledáme vzorek <strong>reminiscence</strong> v textu <code>T</code>, 
z kterého vidíme pouze èást. Danı posun <code>s</code> je neplatnı, nebo na tøetím znaku
od konce došlo k neshodì (pøípomínám, e se vzorek prochází odzadu). Šedì je vyznaèena tzv.
dobrá pøípona <strong>ce</strong>. Je to èást vzorku odzadu, která se shoduje s jistou èástí
textu, vzhledem ke kterému je vzorek zarovnán (jak uvidíme pozdìji tato èást se dá velmi 
jednoduše urèit a z ní se dá spoèítat pøíslušnı posun). Znak <strong>i</strong>, kterı zpùsobil
neshodu (ve vzorku se na stejném místì vyskytuje písmeno <strong>n</strong>) je ji døíve
proklamovanı tzv. špatnı znak.<br>
Na obrázku (b) je naèrtnuto, jak si s neshodou poradí "bad-character heuristic". Ta provede
posun vzorku o tolik pozic doprava, aby špatnı znak v textu byl zarovnán k nejpravìjšímu vıskytu
stejného znaku ve vzorku. Zde je špatnı znak <strong>i</strong>, a jeliko se <strong>i</strong>
vyskytuje ve vzorku na sedmé pozici od konce, musím vzorek posunout o ètyøi pozice doprava, 
aby se dosáhlo poadovaného vısledku. U této heuristiky však existují dvì vıjimky. Pokud se
špatnı znak ve vzorku vùbec nevyskytuje, vzorek se posune o takovı poèet míst, aby první písmeno
vzorku bylo zarovnáno k písmenu, které následuje pøímo po znaku, kterı zpùsobil neshodu.
V podstatì jde o nejlepší monı pøípad a je logické, e pokud je v textu znak, kterı se v daném
vzorku nenachází nemusím se tou èástí textu zabıvat. Druhou vıjimkou je, pokud je nejpravìjší
vıskyt špatného znaku napravo od aktuální pozice, kde byla odhalena neshoda (vzorek by se tedy 
posouval doleva). V tomto pøípadì neposkytuje heuristika ádnou monost.<br>
Na obrázku (c) je zobrazeno chování "good-suffix" heuristiky v pøípadì, e se narazí na neshodu.
Tato heuristika provede posun vzorku doprava o nejmenší poèet znakù, kterı zaruèí, e znaky
ve vzorku, které se po posunu budou nacházet pod dobrou pøíponou bude stejné jako znaky v této
pøíponì, tedy <strong>ce</strong>. V našem pøíkladu je to posun o tøi pozice doprava.<br>
Kdy Boyer-Mooreùv algoritmus narazí na neshodu, dostane v lepším pøípadì dvì doporuèení od
dvou heuristik, o kolik je znakù je mono vzorek bezpeènì posunout (v lepším pøípadì, nebo
heuristika "bad-character" nìkdy doporuèení neposkytne). Algoritmus si tedy logicky vybere
vìtší posun (v našem pøíkladì posun vzorku o ètyøi pozice doprava).
</p>
<p>
Tuto skuteènost (mínìno vybírání a vùbec uití heuristik) je v pseudokódu reflektováno na øádce
(12) v pøípadì, e byl nalezen vıskyt vzorku, nebo na øádce (13) v pøípadì, e došlo k neshodì. 
Zde se vybere vìtší èíslo z <code>j-&#955;[T[s+j]]</code> (poskytnuto heuristikou 
"bad-character") a <code>&#947;[j]</code> (poskytnuto "good-suffix" heuristikou), o které se
zvıší posun <code>s</code>.<br>
Nyní se podíváme, jak jednotlivé heuristiky pøesnì fungují a jak se dají spoèítat posuny, které
poskytují. U nyní je zøejmé, e posuny závisí pouze na vzorku, pøípadnì na abecedì &#931;.
Na prohledávaném textu opìt pøíliš nezáleí.
</p>
<br><strong>Heuristika špatného znaku</strong>
<p>
U bylo poznamenáno, e u této heuristiky se vyuívá znalost nejpravìjšího vıskytu znaku 
ve vzorku, kterı zpùsobil neshodu v textu (<code>T[s+j]</code>). Z toho se poté odvodí poèet
znakù, o kterı se vzorek mùe posunout doprava. Je zøejmé, e v nejlepším pøípadì, kdy dojde
k neshodì hned na prvním porovnávaném znaku (tedy posledním znaku vzorku) a tento špatnı znak
se ve vzorku nevyskytuje, je moné posunout vzorek doprava o celou jeho délku. Pokud k tomu
dochází pøi prohledávání opakovanì, porovná se ve skuteènosti pouhı zlomek celkového poètu
písmen, které prohledávanı text obsahuje. Heuristika "bad-character" tedy zajišuje velmi
vırazné urychlení vyhledávacího procesu a to i díky faktu, e porovnávání vzorku s textem
se provádí zprava doleva.<br>
Jak tedy heuristika ve skuteènosti pracuje? Nebude škodit, kdy k odpovìdi pouijeme trochu
formálnìjšího zápisu.<br>
Nech pøi porovnávání došlo k neshodì. To znamená, e <code>P[j]!=T[s+j]</code> pro nìjaké 
<code>j</code>, pro které platí <code>1&lt;=j&lt;=m</code>. Potom <code>k</code> buï nejvìtší
èíslo takové, e <code>1&lt;=k&lt;=m</code> a zároveò <code>P[k]==T[s+j]</code>, pokud takové
<code>k</code> existuje. Pokud neexistuje, buï <code>k=0</code>. Jedná se tedy o nejpravìjší
vıskyt špatného znaku ve vzorku. Vzorek tedy mùeme bezpeènì posunout o <code>j-k</code> znakù.
V dùkazu tohoto tvrzení se rozlišují tøi moné pøípady podle velikosti <code>k</code>, které 
jsou znázornìny na následujícím obrázku.
</p>
<img src="img/ObrIII8.png" alt="Obr. 8" vspace="10">
<p>
Na obrázku (a) je ilustrován první pøípad, kdy se špatnı znak <code>T[s+j]</code> (v našem
pøíkladì je to písmeno <strong>h</strong>) ve vzorku na jiném místì vùbec nevyskytuje. Vzorek
mùeme tedy bezpeènì posunout o <code>j</code> míst ani bychom vynechali monost vıskytu
vzorku v textu (na obrázku o 11 pozic). Vzorek se zarovná pod písmeno v textu, které následuje
pøesnì za znakem, kterı zpùsobil neshodu. Tvrzení v tomto pøípadì platí, nebo <code>k=0</code>
a vzorek posuneme o <code>j</code> pozic, co je pøesnì <code>j-k</code> míst.<br>
Na dalším obrázku (b) je zobrazen další pøípad, kdy <code>k&lt;j</code>. Nejpravìjší vıskyt
špatného znaku ve vzorku je vlevo od místa <code>j</code>, kde došlo k neshodì. Tudí 
<code>j-k&gt;0</code> a vzorek mohu o tento poèet míst bezpeènì pøemístit doprava. Vıskyt
špatného znaku ve vzorku se potom zarovná ke špatnému znaku v textu. Posun je bezpeènı, protoe
<code>k</code> je index nejblišího znaku, kterı se shoduje se špatnım, vzhledem k posunu. 
To znamená, e všechny posuny o velikost menší ne <code>j-k</code> jsou neplatné a posun
právì o <code>j-k</code> je v tuto chvíli platnı (je moné, e se vylouèí hned v dalším kroku).
Na obrázku máme situaci, kdy <code>k=6</code> a <code>j=10</code>, špatnı znak je 
<strong>i</strong>. Vzorek tedy posunu o ètyøi pozice a <strong>i</strong> budou zarovnaná pod
sebou.<br> 
Poslední obrázek (c) znázoròuje i poslední monost postavení špatného znaku ve vzorku, kdy
<code>k&gt;j</code>. Potom by platilo, e <code>j-k&lt;0</code>, co by znamenalo posunutí
vzorku smìrem doleva (návrat zpátky). Tato monost se v prùbìhu algoritmu automaticky podchytí,
nebo druhá heuristika vdy zaruèí posun alespoò o jedno místo a jeliko algoritmus vybírá
maximum z obou èísel, vdy se v takovémto pøípadì vybere èíslo poskytnuté heuristikou 
"good-suffix". V našem pøíkladu je špatnı znak <strong>e</strong>, <code>j=10</code> a 
<code>k=12</code>.
</p>
<p>
Nyní si uvedeme jednoduchı pseudokód funkce, která heuristiku "bad-character" realizuje. Funkce
dostane na vstup vzorek <code>P</code>, jeho délku <code>m</code> a abecedu &#931;, protoe
posun se musí spoèítat pro kadı znak, kterı se mùe vyskytnout jako špatnı.
</p>
<pre><code>
Last_Occur_func(P,m,&#931;)
  (1)  for kadı znak a z abecedy &#931;
  (2)    &#955;[a]=0
  (3)  for j=1 to m
  (4)    &#955;[P[j]]=j
  (5)  return &#955;
</code></pre>
<p>
Funkce vrací pole &#955;, kde <code>&#955;[a]</code> pøedstavuje pozici nejpravìjšího 
vıskytu znaku <code>a</code> ve vzorku a to pro všechny znaky z abecedy &#931;. V pøípadì,
e se znak ve vzorku nevyskytuje je hodnota rovna nule. &#955; se nazıvá last-occurence 
function èili nìco jako funkce posledního vıskytu.<br>
Urèení èasové sloitosti je jednoduché. Øádka (2) se provede tolikrát, kolik má abeceda &#931;
znakù, tedy |&#931;|-krát. Øádka (4) se provede pøesnì <code>m</code>-krát. Èasová sloitost
je tudí <i>O(|&#931;|+m)</i>.
</p>
<br><strong>Heuristika dobré pøípony</strong>
<p>
V tomto odstavci si ukáeme, jak vypoèítat posuny doporuèované druhou heuristikou, heuristikou
"good-suffix". Pro tento úèel si definujme relaci <code>Q~R</code> pro dva textové øetìzce 
<code>Q</code> a <code>R</code>, pro které platí, e buï <code>Q</code> je pøíponou
<code>R</code> nebo <code>R</code> je pøíponou <code>Q</code>. Tato relace neznamená nic jiného
ne, e pokud oba øetìzce zarovnáme pod sebe podle pravého okraje, budou se ve znacích pod
sebou shodovat. Zároveò platí, e <code>Q~R</code> právì tehdy, kdy <code>R~Q</code>.
</p>
<p>
Další vztah:<br>
Jestlie <code>Q</code> je pøíponou <code>R</code> a zároveò <code>S</code> je pøíponou
<code>R</code>, potom <code>Q~S</code>. Slovy øeèeno to znamená, e pokud je <code>Q</code>
pøíponou <code>R</code> a nìjaké <code>S</code> je také pøíponou <code>R</code>, tak je jasné,
e øetìzce <code>Q</code> a <code>S</code> mají urèitı poèet znakù stejnıch. Tedy buï 
<code>Q</code> je pøíponou <code>S</code> nebo <code>S</code> je pøíponou <code>Q</code>.
To je ale <code>Q~S</code> podle definice ~.
</p>
<p>
Nech pøi porovnávání došlo k neshodì na <code>j</code>-tém místì vzorku (tedy 
<code>P[j]!=T[s+j]</code>), pro nìjaké <code>j&lt;m</code>. Potom heuristika "good-suffix" øíká,
e vzorek mohu bezpeènì posunout o vzdálenost <br>
</p><pre>  &#955;[j]=m-max{k: 0&lt;=k&lt;m &amp; P[j+1..m]~P<sub>k</sub>}
</pre>
Tedy <code>&#955;[j]</code> je nejmenší vzdálenost, o kterou mùeme vzorek posunout, ani
bychom zpùsobili nìjakou neshodu dobré pøípony <code>T[s+j+1..s+m]</code> vùèi odpovídajícím
znakùm novì posunutého vzorku. Tuto situaci si mùeme ukázat na obrázku (b) s pøedchozí 
kapitoly. K neshodì došlo na tøetím znaku vzorku od konce, tedy <code>j=3</code>. Dobrá pøípona
je tedy slovo <strong>ce</strong>, poslední dvì písmena vzorku <strong>reminiscence</strong>.
Z definice &#955; hledáme nejvìtší <code>k</code>, které splòuje, e 
<code>P[j+1..m]~P<sub>k</sub></code>. V našem pøípadì je <code>k=9</code>, nebo 
<code>P[j+1..m]</code> je slovo <strong>ce</strong> (dobrá pøípona) a nejdelší pøedpona vzorku 
<code>P</code> konèící <strong>ce</strong> je slovo <strong>reminisce</strong>, jeho délka je
devìt. Vzorek tedy mùeme posunout o <code>m-k=12-9=3</code> pozice doprava.<br>
Ještì poznamenejme, e funkce &#955; je dobøe definována pro všechna <code>j</code>, nebo
<code>P[j+1..m]~P<sub>0</sub></code> pro všechna <code>j</code> (prázdnı øetìzec je v relaci
se vším). &#955; se nazıvá good-suffix function, v pøekladu funkce dobré pøípony.<br>
Jeliko je naše definice této funkce pro úèely vıpoètu na poèítaèi ponìkud nevhodná, provedeme
nìkolik relativnì jednoduchıch úprav, abychom dostali ekvivalentní definici, ale ve tvaru,
v kterém pùjde pøepsat do našeho pseudokódu.<br>
Nejprve si ukáeme, e platí vztah <code>&#955;[j]&lt;=m-&#960;[m]</code> pro všechna 
<code>j</code>, kde &#960; je prefixová funkce, kterou jsme pouili u KMP algoritmu. Polome
<code>w=&#960;[m]</code>. Z definice prefixové funkce máme, e musí platit, e 
<code>P<sub>w</sub></code> je pøíponou vzorku <code>P</code>. Protoe <code>P[j+1..m]</code> je 
také pøíponou <code>P</code>, dostaneme ze vztahu uvedeného vıše, e nutnì 
<code>P[j+1..m]~P<sub>w</sub></code>. Podle definice &#955; platí, e 
<code>&#955;[j]&lt;=m-w</code> (nebo mám <code>w</code>, které splòuje poadavky, ale nemusí 
to bıt maximální takové èíslo, proto je moné, e <code>&#955;[j]</code> bude menší ne 
<code>m-w</code>). Jeliko máme <code>w=&#960;[m]</code>, plyne odtud rovnou vztah
<code>&#955;[j]&lt;=m-&#960;[m]</code> pro všechna <code>j</code>, co jsme chtìli dokázat.
Díky tomu mùeme naši definici funkce &#955; pøepsat do následující podoby.
<p></p>
<pre>  &#955;[j]=m-max{k: &#960;[m]&lt;=k&lt;m &amp; P[j+1..m]~P<sub>k</sub>}
</pre>
<p>
Tuto definici jsme z pøedchozího dostali následovnì.
</p>
<pre>  (1)  &#955;[j]=m-max{k: 0&lt;=k&lt;m &amp; ...} &lt;= m-&#960;[m]
  (2)  &#960;[m] &lt;= max{k: 0&lt;=k&lt;m &amp; ...}
  (3)  k &gt;= &#960;[m]
</pre>
<p>
Úprava mezi (1) a (2) je triviální. Vztah (3) plyne z (2), nebo nejvìtší <code>k</code> bude
vdy vìtší ne <code>&#960;[m]</code>, proto takhle omezené <code>k</code> mohu hledat od 
zaèátku.
</p>
<p>
Pokraèujme v úpravách naší nové definice &#955;. Z podmínky 
<code>P[j+1..m]~P<sub>k</sub></code> vyplıvá, e buï <code>P[j+1..m]</code> je pøíponou 
<code>P<sub>k</sub></code> nebo <code>P<sub>k</sub></code> je pøíponou <code>P[j+1..m]</code>
podle definice ~. Druhá monost pøímo implikuje, e <code>P<sub>k</sub></code> je pøíponou
celého vzorku <code>P</code> (<code>P<sub>k</sub></code> je pøíponou <code>P[j+1..m]</code>,
co je ale pøípona <code>P</code>. Je tedy jasné, e i <code>P<sub>k</sub></code> je pøíponou
<code>P</code>). Odtud dostaneme vztah, e <code>k&lt;=&#960;[m]</code> z definice &#960;
(máme, e <code>P<sub>k</sub></code> je pøíponou <code>P</code> a zároveò 
<code>&#960;[q]=max{k: k&lt;q &amp; P<sub>k</sub> je pøípona P<sub>q</sub>}</code>. Spojením tìchto
dvou faktù dojdeme ke vztahu <code>&#960;[m]=max{k: k&lt;m &amp; P<sub>k</sub> je pøípona P}</code>.
Odtud plyne, e <code>&#960;[m]&gt;=k</code>, nebo <code>&#960;[m]</code> se rovná maximu, tedy
pro ostatní <code>k</code> je jistì vìtší.). Z této nerovnosti plyne 
<code>&#955;[j]&gt;=m-&#960;[m]</code> a to následovnì.
</p>
<pre>  k &lt;= &#960;[m]
  m-&#960;[m] &lt;= m-k   pro všechna k
  m-&#960;[m] &lt;= m-max{k: ...}=&#955;[j]
  m-&#960;[m] &lt;= &#955;[j]
</pre>
<p>
Definici &#955; mùeme dále upravit.
</p>
<pre>  &#955;[j]=m-max({&#960;[m]} sjednoceno s {k: &#960;[m]&lt;k&lt;m &amp; P[j+1..m] je pøíponou P<sub>k</sub>})
</pre>
<p>
Odtud plyne vıznamná skuteènost, <code>&#955;[j]&gt;0</code> pro všechna <code>j</code> 
(z definice plyne, e buï bude <code>&#955;[j]=m-&#960;[m]</code> a to je urèitì kladné
(víme, e <code>&#960;[m]&lt;m</code>), nebo <code>&#955;[j]=m-k</code> (k je maximem z druhé
mnoiny), v tomto pøípadì je ale <code>&#955;[j]</code> také kladné, nebo 
<code>k&lt;m</code>). To je vìc, kterou jsme potøebovali, protoe zaruèí, e BM algoritmus
bude posunovat vzorek stále doprava (i v pøípadì, e první heuristika vrátí záporné èíslo).<br>
Pokraèujme v naší snaze zjednodušit definici funkce &#955; dále. Pro další úèely si zavedeme
obrácenı vzorek <code>P'</code> vzorku <code>P</code> a tomu odpovídající prefixovou funkci 
&#960;'. Potom <code>P'[i]=P[m-i+1]</code> pro <code>i=1,...,m</code> a <code>&#960;'[t]</code> je
nejvìtší <code>u</code> takové, e <code>u&lt;t</code> a zároveò <code>P'<sub>u</sub></code>
je pøíponou <code>P'<sub>t</sub></code>.<br>
Nech <code>k</code> je nejvìtší èíslo takové, e <code>P[j+1..m]</code> je pøíponou 
<code>P<sub>k</sub></code>, potom <code>&#960;'[l]=m-j</code>, kde <code>l=(m-k)+(m-j)</code>.<br>
Z toho, e <code>P[j+1..m]</code> je pøíponou <code>P<sub>k</sub></code>, plyne 
<code>m-j&lt;=k</code> (<code>P[j+1..m]</code> jako pøípona <code>P<sub>k</sub></code> nemùe
bıt delší ne <code>P<sub>k</sub></code> a délka <code>P[j+1..m]</code> je <code>m-j</code>)
a <code>l&lt;=m</code> (nebo <code>l=(m-k)+(m-j)</code> a pøedchozí nerovnost).<br>
Také platí, e <code>j&lt;m</code> a <code>k&lt;=m</code>, z èeho plyne <code>l&gt;=1</code>
(<code>l=(m-k)+(m-j)</code>. První závorka je díky první nerovnosti kladná, druhá závorka je
díky druhé nerovnosti nezáporná. Celé je to tedy vìtší nebo rovno jedné.).
Jeliko <code>1&lt;=l&lt;=m</code> je funkce &#960;' dobøe definována.<br>
Nyní si dokáeme tvrzení <code>&#960;'[l]=m-j</code>. Jeliko <code>P[j+1..m]</code> je pøíponou 
<code>P<sub>k</sub></code>, máme také <code>P'<sub>m-j</sub></code> je pøíponou
<code>P'<sub>l</sub></code> (pouhé obrácení a pøeindexování). Odtud dostaneme 
<code>&#960;'[l]&gt;=m-j</code> (nebo <code>m-j</code> vyhovuje definici &#960;', hodnota však
mùe bıt díky maximalizaci i vìtší.). Pro spor pøedpokládejme, e <code>p&gt;m-j</code>, kde
<code>p=&#960;'[l]</code>. Podle definice &#960;' máme, e <code>P'<sub>p</sub></code> je pøípona
<code>P'<sub>l</sub></code>. To se však dá napsat také jako <code>P'[1..p]=P'[l-p+1..l]</code>.
Pøepisem vzhledem k pùvodnímu vzorku získáme <code>P[m-p+1..m]=P[m-l+1..m-l+p]</code>. 
Pokud teï pouijeme substituci <code>l=2m-k-j</code>, dostaneme 
<code>P[m-p+1..m]=P[k-m+j+1..k-m+j+p]</code>. Tedy <code>P[m-p+1..m]</code> je pøípona 
<code>P<sub>k-m+j+p</sub></code>. Protoe <code>p&gt;m-j</code>, pak <code>j+1&gt;m-p+1</code>,
a tedy <code>P[j+1..m]</code> je pøípona <code>P[m-p+1..m]</code>. Celkem máme fakt, e
<code>P[j+1..m]</code> je pøípona <code>P<sub>k-m+j+p</sub></code> (to plyne z tranzitivity
"operace suffixování" (<code>A</code> je pøípona <code>B</code> a <code>B</code> je pøípona
<code>C</code>, potom <code>A</code> je pøíponou <code>C</code>)).<br>
Protoe <code>p&gt;m-j</code>, máme <code>k'&gt;k</code>, kde <code>k'=k-m+j+p</code>. Jeliko
<code>k'</code> splòuje definici &#960;' a dokonce <code>k'&gt;k</code>, docházíme ke sporu 
s tím, e <code>k</code> je nejvìtší èíslo splòující definici &#960;'.<br>
Tedy <code>p=&#960;'[l]=m-j</code> a tvrzení je dokázáno.
</p>
<p>
Díky tvrzení máme <code>&#960;'[l]=m-j</code>, z toho plyne <code>j=m-&#960;'[l]</code> a dosazením
do <code>l=(m-k)+(m-j)</code> dostaneme <code>k=m-l+&#960;'[l]</code>. Díky tomu mùeme lépe 
pøepsat definici &#955;.
</p>
<pre>  &#955;[j]=m-max({&#960;[m]} sjednoceno s {m-l+&#960;'[l]: 1&lt;=l&lt;=m &amp; j=m-&#960;'[l]}) =
      =min({m-&#960;[m]} sjednoceno s {l-&#960;'[l]: 1&lt;=l&lt;=m &amp; j=m-&#960;'[l]})
</pre>
<p>
Tato definice je ji natolik dobøe formulována, e se dá pøímo pøepsat do pseudokódu. Funkce
dostane na vstup vzorek <code>P</code> a jeho délku <code>m</code>.
</p>
<pre><code>
Good_suff_func(P,m)
  (1)  &#960;=Prefix_func(P)
  (2)  P'=Obrat(P)
  (3)  &#960;'=Prefix_func(P')
  (4)  for j = 0 to m
  (5)    &#947;[j]=m-&#960;[m]
  (6)  for l = 1 to m
  (7)    j = m-&#960;'[l]
  (8)    if &#947;[j] &gt; l-&#960;'[l]
  (9)      then &#947;[j] = l-&#960;'[l])
 (10)  return &#947;
</code></pre>
<p>
Èasová sloitost této procedury je <i>O(m)</i>. Èasová sloitost v nejhorším pøípadì celého 
BM algoritmu je tedy <i>O((n-m+1)*m+|&#931;|)</i> (sloitost obou heuristik dohromady je 
<i>O(m+|&#931;|)</i> a vyhledávací fáze je v podstatì naivní algoritmus). Ve skuteènosti 
se v bìné praxi dosahuje mnohem lepších vısledkù a tento algoritmus je velmi pouívanı.<br>
Postupem èasu se objevilo nìkolik úprav tohoto algoritmu a dosáhlo se lineární sloitosti i
v nejhorším pøípadì.
</p>
<p align="right"><a href="#obsah">&gt;&gt;&gt;Obsah</a></p>
<br><br>

<a name="byg"><h3>4. Baeza-Yates-Gonnetùv algoritmus (BYG)</h3></a>
<p>
Nyní si pøedvedeme algoritmus, kterı se od pøedchozích liší u svım pøístupem k vyhledávání
v textu. Byl publikován v roce 1992 a autory jsou R. Baeza-Yates a G.H. Gonnet. 
Narozdíl od dvou algoritmù, které jsme si ji objasnili, a kde se vyhledává pomocí
porovnávání znakù ve vzorku a v textu, algoritmus BYG pøišel s ideou vyhledávání pomocí bitovıch
masek. Princip je celkem jednoduchı. I v tomto algoritmu se pouívá pøedpoèítaná tabulka, nyní
je to však tabulka bitovıch vektorù pro kadı znak ze vstupní abecedy &#931;. Kadá bitová
pozice v daném vektoru pro dané písmeno odpovídá pozici tohoto písmena ve vzorku. Z toho plyne,
e kadı vektor musí bıt tak dlouhı jako je danı vzorek. Vektor je posloupnost jednièek, ale
pokud se znak odpovídající tomuto vektoru vyskytuje na <code>k</code>-té pozici ve vzorku, je
na <code>k</code>-té pozici ve vektoru èíslo nula.<br>
Zde existuje nìkolik monıch variant, jak se vektory konstruují. Buï se pozice vektoru èíslují
odleva nebo odprava. Nìkdy jsou vektory nulové a vıskyt znaku ve vzorku je znaèen jednièkou.
Nejbìnìjší je však zpùsob, kterı jsme si ukázali a to je èíslování pozic odprava a vıskyt 
je znaèen nulou. Ukame si na pøíkladu jak taková tabulka vektorù vypadá pro slovo 
<strong>states</strong> za pøedpokladu klasické abecedy &#931;<code>={a,b,...,z}</code>.
</p>
<table>
 <tbody align="center">
   <tr><th><code>Znak</code></th>
   <th><code>Pozice ve vzorku<br>654321</code></th>
   </tr><tr>
     <td><code>a</code></td>
     <td><code>111011</code></td></tr>
   <tr>
     <td><code>b</code></td>
     <td><code>111111</code></td></tr> 
   <tr>
     <td><code>c</code></td>
     <td><code>111111</code></td></tr>
   <tr>
     <td><code>d</code></td>
     <td><code>111111</code></td></tr> 
   <tr>
     <td><code>e</code></td>
     <td><code>101111</code></td></tr>
   <tr>
     <td><code>f</code></td>
     <td><code>111111</code></td></tr> 
   <tr>
     <td><code>...</code></td>
     <td><code>...</code></td></tr>
   <tr>
     <td><code>r</code></td>
     <td><code>111111</code></td></tr>
   <tr>
     <td><code>s</code></td>
     <td><code>011110</code></td></tr> 
   <tr>
     <td><code>t</code></td>
     <td><code>110101</code></td></tr>
   <tr>
     <td><code>u</code></td>
     <td><code>111111</code></td></tr> 
   <tr>
     <td><code>...</code></td>
     <td><code>...</code></td></tr>
 </tbody>
</table>
<p>
Napøíklad písmeno <strong>s</strong> se ve vzorku vyskytuje na první a šesté poslední pozici, 
v odpovídajícím vektoru je tudí první a šestı bit nastaven na nulu.<br>
Na všechny tyto vektory se mùeme podívat jako na masky, kde nula je transparentní ("prùhledná")
a jednièka netransparentní. Tyto masky potom mùeme zarovnat k danému prohledávanému textu.
Uveïme si pøíklad. Nech máme text <strong>misstates</strong>. Potom kdy k písmenùm zarovnáme
odpovídající masky dostaneme následující obrázek.
</p>
<img src="img/ObrIII9.png" alt="Obr. 9" hspace="20" vspace="10">
<p>
Na obrázku je kadá maska zarovnána k odpovídajícímu písmenu. To znamená maska pro 
<strong>m</strong> je zarovnána k písmenu <strong>m</strong> v textu, maska pro 
<strong>i</strong> je zarovnána k <strong>i</strong> atd. Jeliko se v textu vzorek 
<strong>states</strong> nachází je na obrázku seøazeno šest transparentních bunìk pod sebou.
Šedá èára znázoròuje paprsek svìtla, kterım by se daly jednotlivé buòky prosvítit z jedné strany
na druhou.<br>
Abychom vidìli rozdíl mezi tím, kdy se vzorek v textu najde a mezi okamikem, kdy dojde k 
neshodì, ukáeme se další pøíklad. Tentokrát je prohledávanım textem slov 
<strong>mistakes</strong>.
</p>
<img src="img/ObrIII10.png" alt="Obr. 10" hspace="20" vspace="10">
<p>
Na obrázku je vidìt, e maska pro písmeno <strong>k</strong> zamezuje prosvícení bloku
transparentních bitù. To znamená, e v textu se vzorek na tomto místì nenachází.<br>
Nyní si ukáeme, jak by mohl vypadat kód pro hledání vzorku v textu algoritmem BYG (následující
kód vyhledá pouze první vıskyt, pro hledání všech vıskytù je potøeba kód èásteènì upravit).
Nejprve však nìkolik poznámek. Zmínìné prosvícení bunìk se v programu provádí, ovšem digitálnì
pomocí bitovıch operací. Jednotlivé masky se shromaïují v promìnné <code>work</code>, její
poèáteèní hodnota je <code>-1</code> (v dvojkovém doplòku jsou to samé jednièky). S kadım
novım znakem v textu se tato promìnná posune o jeden bit doleva (vynásobí se dvìma), co
odpovídá odsazování masek na obrázcích. Maska pro novı znak se k promìnné <code>work</code>
pøidá pomocí operace OR. V kadém cyklu se poté tato promìnná testuje na pøíslušném bitu
na nulovost (nebo operace OR zachovává nulovost bitù u znakù, které se shodují se vzorkem).
Pokud se nula v bitu vyskytuje je vzorek nalezen, v opaèném pøípadì se pokraèuje dále.<br>
Program dostává na vstup text <code>T</code> a vzorek <code>P</code>. Nejprve se musí vytvoøit
tabulka bitovıch masek a definovat bit, kterı se bude testovat na nulovost (je to vlastnì bit
s indexem délky vzorku).
</p>
<pre><code>
  (1)  n = length(T)
  (2)  m = length(P)
  (3)  masks = Comp_masks(P, &#931;)
  (4)  testbit = 2^m
  (5)  i = 1
  (6)  found = false
  (7)  while (not found &amp;&amp; i &lt; n)
  (8)    while (i &lt; n &amp;&amp; T[i] != P[1])  i = i+1
  (9)    work = -1
 (10)    while (work != -1 &amp;&amp; not found)
 (11)      work = (work shl 1) or masks[T[i]]
 (12)      if (work and testbit = 0)
 (13)        then found = true
 (14)             print("Vzorek byl nalezen na pozici", i+1-m)
 (15)        else i = i+1
</code></pre>
<p>
Cyklus na øádce (8) prochází text do doby ne najde poèáteèní znak vzorku, odtud zaèíná hledat
vzorek podle masek. V cyklu (10)-(15) se provádí vlastní èinnost, tedy posouvání a OR-ování
masky spolu s testem na pøítomnost vzorku.<br>
Abychom si lépe ukázali, jak algoritmus funguje (podle kódu, kterı jsme se sestavili a ne podle
jakési pøedstavy z pøedchozích obrázkù), probereme další pøíklad. Budeme hledat vzorek 
<strong>state</strong> v textu <strong>misstates</strong>. Program tedy podle øádky (8) projde
text a narazí na znak <strong>s</strong>, co je poèáteèní písmeno našeho vzorku. Potom se
promìnná <code>work</code> nastaví na vıchozí hodnotu -1. Následnì se promìnná posune o jeden 
bit doleva (nejpravìjší bit bude nula) a pøioruje se maska pro písmeno <strong>s</strong>.
Jeliko tato maska obsahuje nulu na nejpravìjším bitu, operace OR tuto hodnotu zachová.
Abychom vidìli, co se bude dít dál, uvedeme si tabulku. Hodnota Posun bude vyjadøovat promìnnou
<code>work</code> posunutou o jeden bit doleva, políèko Maska pøedstavuje masku pro dané
písmeno a políèko Vısledek je vısledkem operace OR na pøedchozí dvì hodnoty. Bit, kterı 
se testuje na nulovost je zvıraznìn.
</p>
<table border="1">
 <tbody>
   <tr><th><code>Vstupní znaky</code></th>
   <th><code>Bitové hodnoty</code></th>
   </tr><tr>
    <td align="center"><code>s</code></td>
    <td><code>1111111111111110 
Posun<br>1111111111111110 Maska<br>11111111111<strong>1</strong>1110 Vısledek</code></td>
   </tr>
   <tr>
    <td align="center"><code>s</code></td>
    <td><code>1111111111111100 
Posun<br>1111111111111110 Maska<br>11111111111<strong>1</strong>1110 Vısledek</code></td>
   </tr>
   <tr>
    <td align="center"><code>t</code></td>
    <td><code>1111111111111100 
Posun<br>1111111111110101 Maska<br>11111111111<strong>1</strong>1101 Vısledek</code></td>
   </tr>
   <tr>
    <td align="center"><code>a</code></td>
    <td><code>1111111111111010 
Posun<br>1111111111111011 Maska<br>11111111111<strong>1</strong>1011 Vısledek</code></td>
   </tr>
   <tr>
    <td align="center"><code>t</code></td>
    <td><code>1111111111110110 
Posun<br>1111111111110101 Maska<br>11111111111<strong>1</strong>0111 Vısledek</code></td>
   </tr>
   <tr>
    <td align="center"><code>e</code></td>
    <td><code>1111111111101110 
Posun<br>1111111111101111 Maska<br>11111111111<strong>0</strong>1111 Vısledek</code></td>
   </tr>
 </tbody>
</table>
<p>
Dále algoritmus nepokraèuje, protoe vzorek byl v tomto okamiku odhalen otestováním pøíslušného
bitu na nulu. Nyní si ukáeme obdobnou tabulku pro text, kterı vzorek neobsahuje, napø.
<strong>mistakes</strong>.
</p>
<table border="1">
 <tbody>
   <tr><th><code>Vstupní znaky</code></th>
   <th><code>Bitové hodnoty</code></th>
   </tr><tr>
    <td align="center"><code>s</code></td>
    <td><code>1111111111111110 
Posun<br>1111111111111110 Maska<br>11111111111<strong>1</strong>1110 Vısledek</code></td>
   </tr>
   <tr>
    <td align="center"><code>t</code></td>
    <td><code>1111111111111100 
Posun<br>1111111111110101 Maska<br>11111111111<strong>1</strong>1101 Vısledek</code></td>
   </tr>
   <tr>
    <td align="center"><code>a</code></td>
    <td><code>1111111111111010 
Posun<br>1111111111111011 Maska<br>11111111111<strong>1</strong>1011 Vısledek</code></td>
   </tr>
   <tr>
    <td align="center"><code>k</code></td>
    <td><code>1111111111110110 
Posun<br>1111111111111111 Maska<br>11111111111<strong>1</strong>1111 Vısledek</code></td>
   </tr>
 </tbody>
</table>
<p>
Program v tuto chvíli skonèí vnitøní cyklus, nebo <code>work=-1</code>, co znamená, e
byla nalezena neshoda. Dále by program hledal první znak vzorku (<strong>s</strong>) v textu.
Nyní si ukame jednoduchı kód, kterı pøedpoèítá masky pro všechny znaky abecedy &#931;.
Procedura dostane na vstup vzorek <code>P</code> a abecedu &#931;.
</p>
<pre><code>
  (1)  for kadı znak a z abecedy &#931; 
  (2)    masks[a] = -1
  (3)  j = 1
  (4)  for i = 1 to m
  (5)    masks[P[i]] = masks[P[i]] and not j
  (6)    j = j shl 1
  (7)  return masks
</code></pre>
<p>
Promìnná <code>j</code> slouí k vyznaèování nul v pøíslušnıch vektorech. Poèáteèní hodnotou
je jednièka a s kadım prùbìhem cyklu se hodnota zdvojnásobí (posun o jeden bit doleva).
Napøíklad pokud <code>j=4</code>, co je v bitovém zápisu <code>0000000000000100</code>. Tím,
e operaci AND pouijeme na masku, kterou máme, a na dvojkovı doplòek <code>j</code>
(<code>1111111111111011</code>), vyznaèíme nulu na tøetím bitu masky.<br>
Èasová sloitost této procedury je <i>O(m)</i>, protoe cyklus se vykoná pro kadı znak 
<code>m</code>-krát (cykly jsou sice dva, ale sloitost  <i>O(2*m)</i> odpovídá <i>O(m)</i>
z definice <i>O</i>). Èasová sloitost samotného vyhledávání je <i>O(n)</i> v nejhorším 
pøípadì. Celková sloitost je tedy <i>O(n+m)</i>.
</p>
<p align="right"><a href="#obsah">&gt;&gt;&gt;Obsah</a></p>
<br><br>

<a name="qs"><h3>5. Quicksearch</h3></a>
<p>
V roce 1990 publikoval èlovìk jménem D.M. Sunday algoritmus Quicksearch, kterı se od pøedchozích
vıznamnì liší ve dvou vìcech. Je rychlejší a mnohem jednodušší. Nìkteré jeho rysy jsou podobné
jako u Boyer-Mooreova algoritmu. U BM algoritmu toti v nejlepším pøípadì pøeskoèíme tolik znakù
kolik je délka samotného vzorku. U Quicksearch se, jak uvidíme pozdìji, nejèastìji pøeskakuje
<code>m+1</code> znakù (kde <code>m</code> je délka vzorku). Znamená to, e èasová sloitost
v prùmìrném pøípadì je ménì ne <i>O(n)</i> a blíí se k <i>O(n/(m+1))</i>. To je dùleité
zvláš pro delší vzorky, kde je urychlení opravdu markantní. U Boyer-Mooreva algoritmu se
díky tomu, e vzorek porovnáváme odzadu, v textu vracíme, co mùe zpùsobit problémy s pamìovım
bufferem, které byly popsány v úvodu Knuth-Morris-Prattova algoritmu. Quicksearch nic takového
nedìlá, take se jeví jako bezproblémovı. Má však jiné nevıhody, které jsou popsané v další
kapitole.<br>
Myšlenka tohoto algoritmu je opravdu velice jednoduchá. Na zaèátku jako obvykle zarovnáme vzorek
k prohledávanému textu. Stejnì jako u naivního algoritmu budeme text a vzorek porovnávat znak
po znaku. Postup se ale liší v pøípadì, e objevíme neshodu mezi jednotlivımi písmeny. V tomto
okamiku se podíváme na znak, kterı se nachází v textu pøímo za koncem vzorku (testovı znak).
Pokud se tento znak ve vzorku na ádném místì neobjevuje, ádnı posun, kterı by umístil jakékoli
písmeno vzorku nad testovı znak, nebude platnı. S klidnım svìdomím tedy mùeme celı vzorek 
pøemístit a za testovı znak. To pøedstavuje posun o <code>m+1</code> znakù, kde <code>m</code>
je velikost vzorku. Tato vzdálenost je mnohem lepší ne v pøípadì pøedchozích algoritmù (vèetnì 
BM algoritmu, kde byl posun v tomto pøípadì pouze <code>m</code>).<br>
Pokud se testovı znak ve vzorku na nìjakém místì nachází (pøípadnì na více místech), posuneme
vzorek o nejmenší vzdálenost takovou, e se testovı znak bude shodovat se znakem v novì 
posunutém vzorku, kterı je zarovnán k testovému znaku. Vìtšinou to bude pøedstavovat posun
o více ne jeden znak. Dalším porovnáním zjistíme, jestli byl posun spravnı a vzorek se na 
této pozici ji nachází. Jinak se posuneme stejnım zpùsobem dále. Pro lepší ilustraci, jak
tento algoritmus v textu vyhledává, si uvedeme pøíklad. V následujícím textu budeme hledt vıskyt
vzorku <strong>problems</strong>.
</p>
<img src="img/ObrIII11.png" alt="Obr. 11" hspace="10" vspace="10">
<p>
Na obrázku (a) je vyobrazena vıchozí situace. Hned první znak textu zpùsobuje neshodu. Testovı 
znak je písmeno <strong>h</strong>. Jeliko se takové písmeno ve vzorku nevyskytuje, posuneme
vzorek o jeho délku zvìtšenou o jedna (tedy o devìt znakù). To znamená, e se vzorek posune
a za písmeno <strong>h</strong>.<br>
Situace je ilustrována na obrázku (b). Tentokrát je testovı znak písmeno <strong>e</strong>, 
které se ve vzorku vyskytuje. Proto musíme vzorek posunout tak, aby byly dvì <strong>e</strong>
zarovnány pod sebe. Tato vzdálenost musí bıt o jednu vìtší ne je <strong>e</strong> vzdáleno
od konce vzorku. Vzorek tedy posuneme o <code>8-6+1=3</code> znaky.<br>
Na obrázku (c) opìt došlo k neshodì na prvním porovnávaném znaku. Testovı znak je prázdné 
políèko, které se ve vzorku nevyskytuje. Znovu posuneme vzorek o devìt míst.<br>
Následuje situace z obrázku (d). Zde se stejnì jako u naivního algoritmu porovnají tøi znaky
(<strong>pro</strong>). Na ètvrtém písmenu dojde k neshodì. Protoe testovı znak 
<strong>i</strong> se ve vzorku nevyskytuje, pøemístíme vzorek a za tento testovı znak, tedy
opìt o devìt míst.<br>
Obrázek (e). Zde je opìt testovım znakem písmeno <strong>e</strong> a stejnì jako v pøípadì (b),
posuneme vzorek o devìt míst.<br>
Na obrázku (f) je zobrazena koneèná situace. Vzorek je nalezen a bylo k tomu potøeba pouhıch
pìt posunù a celkem 16 porovnání.
</p>
<p>
Nyní se u mùeme uvést jak bude algoritmus vypadat zapsán v pseudokódu. Na vstup procedura
dostane text <code>T</code>, vzorek <code>P</code> a abecedu &#931;. Procedura opìt vyhledá 
pouze první vıskyt pro nalezení všech vıskytù jsou však tøeba jen drobné úpravy. Tabulku posunù 
<code>shift</code> je nutno pøed samotnım vyhledáváním pøedpoèítat.
</p>
<pre><code>
  (1)  n = length(T)
  (2)  m = length(P)
  (3)  shift = Comp_shift(P,&#931;)
  (4)  pat = 1
  (5)  s = 0
  (6)  while (pat &lt;= m &amp;&amp; pat+s &lt;= n)
  (7)    if P[pat] == T[pat+s] 
  (8)      then pat = pat+1
  (9)      else s = s+shift[T[s+m+1]]
 (10)           pat = 1

Comp_shift(P,&#931;)
  (1)  for kadı znak a z abecedy &#931;
  (2)    shift[a] = m+1
  (3)  for i = 1 to m
  (4)    shift[P[i]] = m-i+1
  (5)  return shift
</code></pre>
<p>
Kód je pouze pøepisem faktù, které tu byly vysvìtleny. Snad jen poznámka k funkci Comp_shift.
V prvním cyklu se všem znakùm pøiøadí hodnota maximálního posunu a teprve poté se provádí pro
znaky, které se ve vzorku vyskytují, pøesnìjší úprava.<br>
V nejlepším pøípadì se neshoda objeví pokadé hned u prvního porovnávaného znaku (u prvního 
myšleno jako prvního po kadém posunu). To znamená, e posun bude pokadé o <code>m+1</code> 
znakù. Èasová sloitost je potom asi <i>O(n/(m+1))</i>. Kompletní analıza èasové sloitosti 
tohoto algoritmu zatím nebyla poskytnuta, ale Sunday tvrdí, e není horší ne <i>O(n)</i>.
</p>
<p align="right"><a href="#obsah">&gt;&gt;&gt;Obsah</a></p>
<br><br>

<a name="srov"><h2>IV. Srovnání algoritmù</h2></a>
<p>
V této kapitole si øekneme vıhody a nevıhody algoritmù, které zde byly popsány. Na jaké úèely 
se hodí a na jaké ne.<br>
První algoritmus, kterému jsme se vìnovali, byl tzv. naivní algoritmus 
(<a href="#naiv">odkaz</a>). Myslím, e nemá cenu se tomuto algoritmu vìnovat moc dlouho, nebo 
svou èasovou sloitostí není pøedurèen k pøíliš velkému pouití. Na druhou stranu pro relativnì 
krátké texty (øádovì o stovkách maximálnì tisících znacích) a krátké vzorky (20 písmen) je tento
algoritmus asi dobrou volbou, a to u jenom z dùvodu, e ostatní efektivní algoritmy si pro své 
potøeby pøedpoèítávají rùzné tabulky, co tento algoritmus nedìlá, a proto se u krátkıch textù 
jeho pomalost neprojeví a vzhledem ke své jednoduchosti implementace je mnohdy pouíván 
(implementace v assembleru, pouití v jednoduchıch textovıch editorech apod.). Jeho nevıhodou 
je, e pøi pouití pro vyhledávání v souborech mùe dojít k problému s pamìovım bufferem, kterı 
je popsán v úvodu kapitoly vìnované Knuth-Morris-Prattovu algoritmu.<br>
Dalším algoritmem, kterı jsme si ukazovali, je právì Knuth-Morris-Prattùv algoritmus 
(<a href="#kmp">odkaz</a>). Tento algoritmus odstraòuje hlavní nevıhody naivního algoritmu. 
Je to pøedevším vícenásobné testování jednoho znaku a vracení se v textu. Díky tomu je vhodnı 
pro vyhledávání v textovıch souborech, nebo nevznikají problémy s pamìovım bufferem 
(pravdìpodobnost, e se tento problém vyskytne, je sice malá, ale pøihodit se mùe). 
Nevıhodou ale je, e se stále porovnávají všechny znaky textu (i kdy jak uvidíme pozdìji, 
pro jisté speciální úèely je to nezbytné). Algoritmus se hodí pro vyhledávání vzorkù, o kterıch
nejsou k dispozici ádné informace, a tedy není jisté, jestli by bylo vıhodnìjší pouít 
obyèejnı naivní algoritmus.<br>
V další kapitole jsme se vìnovali algoritmu Boyera a Moorea (<a href="#bm">odkaz</a>). Tento 
algoritmus je asi všeobecnì nejlépe pouitelnı i pøes svou relativní sloitost implementace.
Je zvláštì vhodnı pro vzorky vìtší délky a pro relativnì velkou abecedu znakù, kde se obì
heuristiky mohou plnì uplatnit. Narozdíl od pøedchozích algoritmù, tento prozkoumá pouze
zlomek všech znakù v textu (to se ale v nìkterıch pøípadech mùe nevyplatit). Bohuel díky
zpìtnému porovnávání vzorku s textem mùe dojít stejnì jako u naivního algoritmu k problémùm
s pamìovım bufferem, kterı vyaduje další reii vıpoètu. I pøes nepøíliš dobrou èasovou 
sloitost je v prùmìru velmi dobrı.<br>
Následuje algoritmus Baeza-Yates-Gonnet (<a href="#byg">odkaz</a>). Tento algoritmus je velmi
specifickı, a proto jsou s ním spjatá i jistá omezení co do implementace. Prvním omezením je
poadavek na schopnost programovacího jazyka (a poèítaèe) provádìt bitové operace OR, AND a 
bitovı posun, na èíslech typu <code>integer</code>. Druhım a po pravdì øeèeno asi drastiètìjším 
omezením je délka bitovıch masek, které se v algoritmu pouívají. Tyto masky musí mít stejnou 
délku jako danı vzorek. Dnešní poèítaèe poèítají vše buï v 32-bitové nebo v 64-bitové 
aritmetice, co je omezení pro kompilátory programovacích jazykù a tím i pro délku bitové masky. 
Proto v pøípadì, e chceme hledat vzorek delší ne 32 (potamo 64) bitù, není tento algoritmus i 
pøes svou rychlost tou správnou volbou. Na druhou stranu, pokud chceme sestrojit algoritmus, 
kterı nebude case-sensitive (tedy nebude rozlišovat velikost písmen), není problém upravit
Baeza-Yates-Gonnetùv algoritmus tak, aby tento poadavek bez problémù øešil. Staèí pouze 
vyrobit masky zvláš pro velká a malá písmena a trochu upravit vyhledávací èást.<br>
Tím se dostáváme k poslednímu algoritmu, kterı zde byl popsán, Quicksearch 
(<a href="#qs">odkaz</a>). Nejdøíve dvì fakta. Za prvé tento algoritmus se stejnì jako KMP a BYG 
v textu nevrací zpìt. Za druhé, stejnì jako Boyer-Mooreùv algoritmus i tento pøeskakuje velké 
mnoství neporovnanıch znakù. Jak bylo øeèeno, je tato skuteènost vıhodou co do urychlení 
algoritmu, ale ve speciálních pøípadech není toto pøeskakování ádoucí. Takovım pøíkladem mùe 
bıt situace, kdy pøi kadém nalezení vzorku v textu chceme, aby program nahlásil èíslo øádky, 
kde se vzorek vyskytuje. V pøípadì, kdy program poèítá kadı znak pro novou øádku a tento znak 
se posunutím vzorku o nìkolik pozic pøeskoèí, dochází pøi nahlášení vıskytu vzorku ke zkreslení 
informace o èísle øádky. Proto je pøi vıbìru algoritmu nutné uvaovat, k èemu bude slouit.
Testy ukázaly (na textech o délce pøiblinì 200000 znakù), e Quicksearch si velmi dobøe poèíná 
v situacích, kdy je vzorek relativnì delší. Pøi nejèastìjších délkách vzorkù (od šesti do osmi
písmen) porovná algoritmus pouze pøiblinì jednu šestinu všech znakù. Záleí však i na tom, jak
vzorek vypadá. Existují dvì upravené verze (<em>maximal shift algorithm</em> a <em>optimal shift
algorithm</em>), které dosahují o pìt procent lepších vısledkù ne základní algoritmus. Vzhledem
k tomu, e pøed vlastním vyhledáváním pøedpoèítávají spoustu rùznıch vìcí, jsou ale vhodné 
pouze pro texty délky øádovì o stotísících znacích.
</p>
<p align="right"><a href="#obsah">&gt;&gt;&gt;Obsah</a></p>
<br><br>

<a name="zav"><h2>V. Závìr</h2></a>
<p>
V tomto dokumentu jsme popsali nìkolik algoritmù zabıvajících se vyhledáváním vzorkù v textu.
Všechny mají jednu vlastnost spoleènou, vyhledávají jeden vzorek v textu. Samozøejmì existují
i algoritmy, které vyhledávají celé mnoiny vzorkù (algoritmus Aho-Corasickové, algoritmus
Commentz-Walterové) i mnoiny zadané pomocí regulárních vırazù (B-algoritmus). I pøesto jsou
tyto algoritmy velice uiteèné a svou vzájemnou rozdílností je spektrum jejich pouitelnosti
pomìrnì široké. Dále jsme si uvedli vıhody a nevıhody jednotlivıch algoritmù, k èemu se
hodí a k èemu. U kadého je vedle podrobného vysvìtlení i pseudokód, podle kterého by nemìl
bıt problém danı algoritmus naprogramovat.<br>
Tento dokument je tedy jakısi úvod do problematiky vyhledávání v textu, nebo tato úloha
je velice rozsáhlá a zasahuje do mnoha oborù teoretické informatiky.
</p>
<p align="right"><a href="#obsah">&gt;&gt;&gt;Obsah</a></p>
<br><br>

<a name="ref"><h2>VI. Literatura</h2></a>
<p>
Zde jsou uvedeny pouité materiály.
</p>
<ul>
 <li>T.H.Cormen, C.E.Leiserson, R.L.Rivest: Introduction to Algorithms, MIT Press 1990, kapitola
34 - String matching
 </li><li>Ivana Vovsová: Vyhledávání vzorkù v textu, diplomová práce, MFF 1994
 </li><li>String Searching, èlánek z neznámé knihy od neznámého autora
 </li><li>A. Koubková, J. Pavelka: Úvod do teoretické informatiky, MFFPress 1998
</li></ul>
<p align="right"><a href="#obsah">&gt;&gt;&gt;Obsah</a></p>

</body></html>