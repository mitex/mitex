\documentclass[a4paper,11pt]{article}
\usepackage{ulem}
\usepackage{a4wide}
\usepackage[dvipsnames,svgnames]{xcolor}
\usepackage[pdftex]{graphicx}
\title{Referát o vyhledávání v textu}
\usepackage[cp1250]{inputenc}
\usepackage{hyperref}
% commands generated by html2latex


\begin{document}

Miroslav Beneš, 2001
\\Informatika I/2/31
\begin{center}


\section{Vyhledávání v textu}
\end{center}
\\
\\
\\
\\

\subsection{\hypertarget{obsah}{Obsah}}
\begin{enumerate}
	\item \hyperlink{uvod}{Úvod}
	\item \hyperlink{zpoj}{Základní pojmy}
	\item \hyperlink{alg}{Algoritmy}
\begin{enumerate}
	\item \hyperlink{naiv}{Naivní algoritmus}
	\item \hyperlink{kmp}{Knuth-Morris-Prattùv algoritmus (KMP)}
	\item \hyperlink{bm}{Boyer-Mooreùv algoritmus (BM)}
	\item \hyperlink{byg}{Baeza-Yates-Gonnetùv algoritmus (BYG)}
	\item \hyperlink{qs}{Quicksearch}
\end{enumerate}
	\item \hyperlink{srov}{Srovnání algoritmù}
	\item \hyperlink{zav}{Závìr}
	\item \hyperlink{ref}{Literatura}
\end{enumerate}
\\
\\

\subsection{\hypertarget{uvod}{I. Úvod}}

V dnešní dobì, kdy se vìtšina dokumentù (a u na úøadech nebo v bìnıch podmínkách) vede na poèítaèích, a tedy v elektronické podobì, je potøeba míti dostateènì silnénástroje k tomu, aby se v danıch dokumentech vyhledal nìjakı text (slovo, vìta apod.)v co nejkratším moném èase. Proto se øadu let vyvíjí rùzné algoritmy, které tento úkols odlišnımi úspìchy plní.
\\Tyto algoritmy jsou bìnému uivateli poèítaèe schovány v jinıch vìtších celcích jako jsourùzné textové editory, kde je obèas nutné nìjaké to slovo v textu vyhledat (potamo zamìnitza jiné). Dalším pøíkladem mohou bıt vyhledávací systémy v knihovnách, vyhledávání v databázích, všelijaké vyhledávací servery apod. Principy vyhledávání vzorkù v textu se také pouívají i v jinıch oborech ne v informatice, pøíkladem mùe bıt napøíkladhledání "vzorkù" v DNA šroubovici.
\\Z toho vyplıvá, e vyhledávání v textu je pomìrnì rozsáhlı problém o jeho uiteènostijistì není sporu. Proto je urèitì uiteèné uvést si nìjaké pøíklady algoritmù, které tentoproblém øeší, popsat je a porovnat.

Algoritmy se mohou dìlit do nìkolika monıch kategorií podle toho za jakım úèelem se pouívají nebo podle svého pùvodu. Mùeme se tedy setkat s algoritmy, které vyhledávajípouze jeden vzorek v daném textu, v jinıch pøípadech je mono vyhledávat mnoinu vícevzorkù. Rozdíl je také v tom, e nìkteré algoritmy naleznou pouze první vıskyt vzorkuv textu, jiné naleznou všechny vıskyty.Existují algoritmy, které se inspirovaly i jinımi obory informatiky jako je napø. teorieautomatù.

V tomto èlánku bych se rád vìnoval zejména dvìma algoritmùm. Prvním je Knuth-Morris-Prattùv algoritmus (KMP), druhım je Boyer-Mooreùv algoritmus (BM). Spoleènım rysem obou jeskuteènost, e vyhledávají všechny vıskyty jednoho vzorku v daném textu. Na KMP se dánahlíet jako na upravenı koneènı (v tomto pøípadì vyhledávací) automat. BM se na druhoustranu jeví jako naivní vyhledávací algoritmus (\hyperlink{naiv}{viz dále}) se dvìmidùleitımi heuristikami.
\\Pøedstavitelem skupiny algoritmù, které vyhledávají celou mnoinu vzorkù je napø.algoritmus Aho-Corasickové, kterı je zaloen na poznatcích právì z teorie automatù.
\\V dalším odstavci bych rád zmínil další dva zajímavé a relativnì nové algoritmy: Baeza-Yates-Gonnet, kterı je zaloen na vyhledávání pomocí bitovıch masek, a algoritmusQuicksearch, jeho autorem je D.M. Sunday.

Nejprve si však zaveïme nìkolik dùleitıch pojmù a definic, které se budou hodit k pozdìjšímu popisu a zkoumání algoritmù.

\hyperlink{obsah}{$>$$>$$>$Obsah}
\\
\\

\subsection{\hypertarget{zpoj}{II. Základní pojmy}}

I pøesto, e vìtšina lidí v principu chápe, co vyhledávání v textu je, definujme sitento pojem alespoò trochu pøesnìji a formálnìji.
\\Nejprve si vysvìtlíme nìkteré základní pojmy potøebné pro popis daného problému. \textbf{Abecedou $\Sigma$ }rozumíme koneènou mnoinu znakù. Napøíklad $\Sigma$
\texttt{=\{0,1\}} nebo $\Sigma$
\texttt{=\{a,b,...,z\}}. Prvky této mnoiny se èastonazıvají znaky, písmena nebo symboly. \textbf{Slovem} v abecedì $\Sigma$ je mínìnakoneèná posloupnost znakù z této abecedy. Prázdnım slovem se rozumí posloupnost délky0 a obvykle se znaèí \textit{$\epsilon$} (\textit{$\epsilon$} nepatøí do $\Sigma$).
\\Mnoina všech slov v abecedì $\Sigma$ se znaèí $\Sigma$$^*$. Na této mnoinì je definovánaoperace \textbf{skládání (konkatenace)}, která dvìma slovùm 
\texttt{x} a 
\texttt{y} délek 
\texttt{m} a 
\texttt{n} pøiøadí slovo 
\texttt{xy} délky
\texttt{m+n}. Tato operace je asociativní (to znamená, e 
\texttt{(xy)z} je to saméslovo jako 
\texttt{x(yz)}) a pro více ne jednoprvkovou abecedu nekomutativní(v pøípadì jednoprvkové abecedy: 
\texttt{aa}"=" 
\texttt{aa}, pokud $\Sigma$
\texttt{=\{a\}}; v pøípadì víceprvkové napø. 
\texttt{xy} není rovno 
\texttt{yx} pro 
\texttt{x, y} navzájem rùzná). Roli jednotkového prvku této operace hraje prázdné slovo\textit{$\epsilon$}, tedy 
\texttt{x}\textit{$\epsilon$}
\texttt{=}\textit{$\epsilon$}
\texttt{x=x} pro kadé 
\texttt{x} z \textit{$\epsilon$}. 
\\Nech 
\texttt{x} je prvkem $\Sigma$$^*$. Potom délkou slova 
\texttt{x} rozumímepoèet znakù v 
\texttt{x}. Zapisujeme 
\texttt{|x|}. Tedy jak bylo poznamenáno 
\texttt{|}\textit{$\epsilon$}
\texttt{|=0}.
\\Øekneme, e slovo 
\texttt{x} z $\Sigma$$^*$ je \textbf{pøedponou (prefixem)}slova 
\texttt{y} z $\Sigma$$^*$, existuje-li takové slovo 
\texttt{u} z$\Sigma$$^*$, e 
\texttt{xu=y}. Takové 
\texttt{u} zøejmì existuje nejvıše jednoa je-li neprázdné, øíkáme, e 
\texttt{x}\textbf{vlastní pøedpona}. Obdobnì, øekneme, e slovo 
\texttt{x} z $\Sigma$$^*$ je \textbf{pøíponou (suffixem)}slova 
\texttt{y} z $\Sigma$$^*$, existuje-li takové slovo 
\texttt{v} z$\Sigma$$^*$, e 
\texttt{vx=y}. Opìt takové 
\texttt{v} existuje nejvıše jednoa je-li neprázdné, mluvíme o \textbf{vlastní pøíponì}.Zøejmì platí, e \textit{$\epsilon$} je vlastní pøíponou a pøedponou kadého slova z $\Sigma$$^*$. Podobnì kadé slovo je svou jedinou nevlastní pøíponou i pøedponou.
\\Pro pøíklad si uveïme, e slovo 
\texttt{\textbf{ab}} je pøedponou slova 
\texttt{\textbf{ab}bdad} a to pøedponou vlastní. Zároveò je vlastní pøíponou slova
\texttt{abb\textbf{ab}}.
\\Pro další úèely si zaveïme ještì jeden jednoduchı pojem, \textbf{prefix o 
\texttt{k} znacích.} Prefix vzorku 
\texttt{P[1..m]} o 
\texttt{k} znacích, tedy 
\texttt{P[1..k]},budeme znaèit 
\texttt{P$_k$}. Podobnì budeme mít tento pojem i pro prohledávanı text(
\texttt{T$_k$}).
\\Nyní se vrame k formulaci problému vyhledávání v textu. Nech máme danou abecedu $\Sigma$ a tím i mnoinu $\Sigma$$^*$. Pøedpokládejme, e máme dány dva textové øetìzce (nejlepší je pøedstavit si je jako pole jednotlivıch znakù). Øetìzec 
\texttt{P = p$_1$...p$_m$} (nebo jako pole znakù 
\texttt{P[1..m]}) budeme nazıvat \textbf{vzorek}. Jeho délka je 
\texttt{m}. Øetìzec 
\texttt{T = t$_1$...t$_n$} (
\texttt{T[1..n]}) bude prohledávanı textdélky 
\texttt{n}. Oba øetìzce jsou slova z $\Sigma$$^*$.
\\Øíkáme, e vzorek 
\texttt{P} se v textu 
\texttt{T}\textbf{ nachází s posunutím 
\texttt{s}} (jinımi slovy øeèeno, nachází se v textu 
\texttt{T}\textbf{ na pozici 
\texttt{s+1}}), jestlie 
\texttt{0$<$=s$<$=n-m} a zároveò 
\texttt{T[s+1..s+m]=P[1..m]} (pro všechna 
\texttt{j 1$<$=j$<$=m t$_s+j$=p$_j$}). Pokud se vzorek 
\texttt{P} v prohledávaném textu 
\texttt{T} nachází nazıváme 
\texttt{s}\textbf{platnım posunem }. Jinak je tento posun \textbf{neplatnı}. Problém vyhledávání jednoho vzorku v textu lze tedy formulovat jako problém nalezení všech platnıch posunù, se kterımi se vzorek 
\texttt{P} nachází v textu 
\texttt{T}.
\includegraphics{PReferat_files/ObrII1.gif}

Tento obrázek znázoròuje pøedchozí definici o vyhledávání v textu. Vzorek 
\texttt{P=bbcab}se nachází v textu 
\texttt{T} s platnım posunem 4, neboli na 5. pozici.

\hyperlink{obsah}{$>$$>$$>$Obsah}
\\
\\

\subsection{\hypertarget{alg}{III. Algoritmy}}

Po vysvìtlení všech potøebnıch pojmù a formulaci daného problému se mùeme zaèít zabıvat jednotlivımi algoritmy. Nejprve se zlehka podíváme na naivní vyhledávací algoritmus a jehoèasovou sloitost, aby se urèitım zpùsobem zdùvodnila potøeba lepších a efektivnìjšíchvyhledávacích algoritmù. Poté probereme ji zmínìné dva algoritmy (Knuth-Morris-Pratt aBoyer-Moore).

\subsubsection{\hypertarget{naiv}{1. Naivní algoritmus}}

Tento algoritmus je v podstatì vısledkem první myšlenky, která kadého napadne, kdy dostaneza úkol navrhnout algoritmus na vyhledávání v textu. Jednoduše øeèeno spoèívá v prozkoumánívšech moností (ne tedy doslova, ale v principu ano). Jak tomu u takovıch algoritmù bıvá,jeho èasová sloitost není pøíliš dobrá.
\\Myšlenka je jednoduchá. Budeme procházet zadanı text a na kadé pozici zkontrolujeme, zdatu nezaèíná danı vzorek. Princip znázoròuje následující obrázek.
\includegraphics{PReferat_files/ObrIII2.gif}

Jak je z obrázku vidno, vzorek se jakoby postupnì posouvá pod danım textem a na kadém místìse kontroluje, zda se zde nenachází pøíslušnı vzorek. V tomto pøíkladu byl vzorek nalezen nadruhé pozici (s posunem 1, pøípad (b)). V ostatních pøípadech vdy nastala na urèitém místì vzorku kolize.
\\Neefektivnost tohoto algoritmu spoèívá právì ve skuteènosti, e pokud narazím na neshodu, posunuvzorek pouze o jedno místo doprava a zaènu porovnávat znovu, a to a do konce prohledávanéhotextu. Tímto postupem se tedy nevyuívají informace, které byly získány v pøedchozím kroku.Napøíklad u našeho obrázku po tom, co jsem našel vzorek v pøípadì (b), nemusím kontrolovatpozici o jednu vpravo, ale mohu pøistoupit a k nákresu pod písmenem (d).
\\Tyto informace, které závisí právì na zadaném vzorku se snaí vyuívat efektivnìjší algoritmy, které si zde ukáeme.
\\Naivní algoritmus by v pseudokódu mohl vypadat asi následovnì:
\begin{verbatim}

\texttt{
  (1)  n = length(T)
  (2)  m = length(P)
  (3)  for s = 1 to n-m+1
  (4)   if T[s..s+m-1] == P[1..m]
  (5)    then print("Vzorek se nachází na pozici", s)
}\end{verbatim}

Nyní se kód rozeberme a podívejme se na èasovou sloitost algoritmu. První dvì øádky obstarávajípouze uloení délky obou textovıch øetìzcù do promìnnıch 
\texttt{n} a 
\texttt{m}.Posouvání vzorku pod textem zajišuje cyklus, kterı zaèíná na øádce (3). Provede se pøesnì(n-m+1)-krát, co je poèet pozic, na kterıch se mùe vzorek vyskytovat. Øádka (5) jen informujeo nalezení vzorku v textu. Pro urèení èasové sloitosti je klíèová øádka èíslo 4. Zde seprovádí porovnávání vzorku s danım textem. Tento pseudozápis mùe ve skuteènosti bıt while cyklus, kterı porovnává jednotlivé znaky dokud nenarazí na neshodu nebo na konec vzorku, v tomtopøípadì se vykoná øádka (5). Je snadné nahlédnout, e v nejhorším pøípadì (to je e vdy projduvšechny znaky ve vzorku) se while cyklus provede m-krát. Èasová sloitost v nejhorším pøípadìje tedy \textit{O((n-m+1)*m)}.

\hyperlink{obsah}{$>$$>$$>$Obsah}

\subsubsection{\hypertarget{kmp}{2. Knuth-Morris-Prattùv algoritmus (KMP)}}

Mezi prvními, kteøí si uvìdomili, e informace, které získává naivní algoritmus svım porovnávánímznak po znaku, mohou bıt velmi cenné pro návrh efektivního algoritmu, byl právì Knuth se svımispoleèníky Morrisem a Prattem. Jejich nápad spoèíval v tom, e pokud se tyto informace vyuijísprávnım zpùsobem, mùe se vzorek nad prohledávanım textem posouvat i o více ne pouze o jedenznak doprava. Tím se vıznamnì zkrátí doba potøebná k prohledání textu. Také je zbyteèné sev prohledávaném textu vracet ke znakùm, které ji byly analyzovány tak jak to èiní naivní algoritmus. Toto vracení spoèívá ve skuteènosti, e pokud pøi porovnávání vzorku s danım textemnarazím na neshodu, vrátím se zpìt na zaèátek vzorku a ten posunu o jedno místo doprava. Tato èinnost je zøejmì zbyteèná, nebo já ji mám informaci o pøedchozích znacích, staèí jipouze dostateènì vyuít. Vracení se v textu mùe pøinést i další problém, kterı není na první pohled zøejmı. Pøi zpracovávání delšího textu, urèitì není tento text v pamìti poèítaèe celı.Ze souboru se naèítá po kusech do nìjakého bufferu v pamìti, se kterım se poté pracuje.Podívejme se na následující pøíklad.
\includegraphics{PReferat_files/ObrIII3.gif}

Dejme tomu, e v takovémto textu hledáme vıskyt slova \textbf{kapka}. Dva øádky v obrázkupøedstavují dva kusy textu tak, jak jsou naèteny do pamìti (bufferu). Naivní algoritmusprochází prvním bufferem a na konci s podezøením, e se nachází uprostøed vzorku naète novıkus textu a tento zahodí. Ovšem hned u prvního znaku zjistí neshodu a vzhledem ke své funkci munezbude nic jiného ne se v textu vrátit. To ale pøedstavuje další pøístup na disk, nebo se musínaèíst pøedchozí kus textu. Princip algoritmu KMP zajistí, e se nic takového nestane.
\includegraphics{PReferat_files/ObrIII4.gif}

Tento obrázek je pøíkladem vıpoètu KMP algoritmu. Porovnávání vzorku s textem zaèíná jako obvykleu prvního znaku zleva (vzorek je zarovnán s textem). Algoritmus postupuje dokud nenarazí naneshodu na ètvrté pozici mezi znaky \textbf{b} a \textbf{g} (obrázek (a)).Z pøedchozích znakù okamitì víme, e posun vzorku o jeden nebo dva znaky nemá vıznam. Posun o tøi znaky ale mùe splnit úèel. Tím se vzorek zarovná s textem nad znakem, kde nastala neshoda.Odtud dále mùe pokraèovat porovnávání. Jak vidno na této pozici se hned první písmeno vzorkuneshoduje se znakem v textu (obrázek (b)), vzorek se poté posune o jedno místo doprava.Velikost takového posunu (o tøi v prvním nebo o jeden znak v dalších pøípadech) závisí pouzena charakteru a formì kadého vzorku. Posun je nezávislı na prohledávaném textu. Jeho velikosturèuje tzv. \textbf{prefixová funkce}.
\\Díky prefixové funkci si pøed spuštìním vlastního vyhledávacího algoritmu pøedpoètu hodnotyposunù pro jednotlivé pozice ve vzorku do nìjaké tabulky. Mnoho efektivních vyhledávacích algoritmù pouívá podobné pøedpoèítané tabulky, které se pozdìji v prùbìhu vyhledávání pouívají.Tedy jak je patrné algoritmus KMP bude mít dvì fáze. V první fázi si z daného vzorku vypoèítámepotøebné hodnoty posunù. Druhá fáze bude uskuteèòovat vlastní vyhledávání.
\\Nejdøíve se tedy vìnujme první fázi a prefixové funkci. Tato funkce vyjadøuje chování vzorkuvzhledem k posunùm k sobì samému. Uveïme si ještì jeden pøíklad.
\includegraphics{PReferat_files/ObrIII5.gif}

Na obrázku (a) vidíme, e pøi takovémto zarovnání (s posunem 
\texttt{s}), se prvních pìtpísmen vzorku shoduje s pìti písmeny v textu (
\texttt{q=5}), pøièem na znaku šestém došlok neshodì. Z informace, e pìt písmen se shodovalo, mùeme okamitì vyvodit, které to byly, nebo je to prvních pìt písmen ve vzorku, a také mùeme zjistit pøíslušnı posun. Je moné urèitposuny, o kterıch ji teï mohu prohlásit, e jsou neplatné, a tím je v budoucnu pøeskoèit. Zdeje na první pohled jasné, e posun o jedno políèko doprava (tedy posun 
\texttt{s+1}) jeneplatnı, nebo první písmeno ve vzorku (\textbf{a}) by bylo zarovnáno k písmenu v textu,o kterém ji máme informaci, e se shodovalo s druhım písmenem ve vzorku (\textbf{b}).Posun 
\texttt{s+2} na obrázku (b) naopak dává jistou nadìji, e by vzorek mohl bıt nalezenna tomto místì, nebo tøi znaky se shodují.
\\K navrení kódu, kterı vypoèítá dané hodnoty je tedy tøeba vyøešit následující problém. Nechmáme dány znaky 
\texttt{P[1..q]}, o kterıch víme, e se shodují s tìmito znaky v textu
\texttt{T[s+1..s+q]} (v našem pøíkladu je to slovo \textbf{ababa}, na obrázku vybarvená políèka). Jakı je nejmenší posun 
\texttt{s'$>$s} takovı, aby platilo
\texttt{P[1..k]=T[s'+1..s'+k]}, pøièem 
\texttt{s'+k=s+q}. Slovy øeèeno to znamená pøesnìto, o co se snaíme. Jak moc mùeme vzorek posunout doprava tak, aby se pøedpona vzorku kratší ne poèet znakù (\textbf{aba}ba), které se pøedtím shodovaly (ababa, tedy 5), shodovalas pøíponou slova v textu (ab\textbf{aba}), které bylo støedem shody (ababa). Pokud takovápøedpona není (
\texttt{k=0}) posuneme vzorek o poèet znakù, které se shodovaly (
\texttt{q=5}).
\\Tedy posun 
\texttt{s'} je nejmenší takovı, e je vìtší ne 
\texttt{s} a není nezbytnìneplatnı. Jak bylo øeèeno v nejlepším pøípadì je novı posun 
\texttt{s'} roven 
\texttt{s+q}. V kadém pøípadì ji nemusíme porovnávat prvních 
\texttt{k} znakù vzorku,nebo jejich shodu v textem máme zaruèenou.
\\Tyto informace se dají spoèítat porovnáváním vzorku se sebou samım, jak je hrubì naznaèenona obrázku (c). Víme, e 
\texttt{T[s'+1..s'+k]} (ab\textbf{aba}) je èást známéhotextu, a tedy to musí bıt pøípona jisté èásti 
\texttt{P}, která také byla prozkoumána.Je to pøesnì pøípona 
\texttt{P$_q$}. Nyní mùeme pøesnì formulovat poadavek na posun 
\texttt{s'} a to pro kadou pozici ve vzorku.
\\Nech mám vzorek 
\texttt{P[1..m]}, potom prefixová funkce (udává posuny 
\texttt{s'})vypadá následovnì:
\begin{verbatim}

\texttt{
  $\pi$ : \{1,...,m\} -$>$ \{0,...,m-1\}, taková e

    $\pi$[q]= max\{k: k$<$q and P$_k$ je pøíponou P$_q$\}.
}\end{verbatim}

Pro prefixovou funkci dále platí, e pro kadé 
\texttt{q} z \{1,...,m\} je $\pi$[
\texttt{q}]$<$
\texttt{q}.
\\
\\\textit{Pozn. $\pi$[q] tedy pøedstavuje délku nejdelší pøedpony 
\texttt{P}, která je pøíponou 
\texttt{P$_q$}.}

Nyní se podívejme, jak bude algoritmus KMP fungovat jako celek. Tedy první fází je vıpoèet prefixové funkce, kterı jsme si v principu popsali. Následuje fáze druhá, vyhledávání.Princip je velice jednoduchı. Na zaèátku zarovnám vzorek vùèi textu a zaènu porovnávat. Pokudnarazím na neshodu, podívám se do tabulky prefixové funkce s indexem, kterı odpovídá pozici vevzorku, kde došlo k neshodì. S tabulky zjistím èíslo, které udává znak vzorku (èíslo urèujejeho pozici ve vzorku) kterı se, kdy pøíslušnì zarovnám vzorek k textu, bude nacházet pøesnìnad znakem v textu, kterı byl pøíèinou neshody (vzorek se tedy posune doprava). Vzorek budu tímtozpùsobem posouvat doprava dokud nenarazím na jeho zaèátek nebo nebudu moci pokraèovat od danépozice dalším porovnáváním. Takto pokraèuji dokud nenarazím na konec textu. Pokud vzorek v textu najdu, oznámím to a pokraèuji dále (dá se toti uvaovat, e u posledního znaku ve vzorku došlo k neshodì).
\\Nyní si ji mùeme uvést zápis algoritmu v pseudokódu (na vstupu je text 
\texttt{T} a vzorek
\texttt{P}).
\begin{verbatim}

\texttt{
  (1)  n = length(T)
  (2)  m = length(P)
  (3)  $\pi$ = Prefix\_func(P)
  (4)  q = 0
  (5)  for i = 1 to n
  (6)    while (q $>$ 0 \&\& P[q+1] != T[i]) q = $\pi$[q]
  (7)    if P[q+1] == T[i] then q = q+1
  (8)    if q = m then 
  (9)      print("Vzorek se nachází na pozici", i-m+1)
 (10)      q = $\pi$[q]

Prefix\_func(P)
  (1)  m = length(P)
  (2)  $\pi$[1] = 0
  (3)  k = 0
  (4)  for q = 2 to m
  (5)    while (k $>$ 0 \&\& P[k+1] != P[q]) k = $\pi$[k]
  (6)    if P[k+1] == P[q] then k = k+1
  (7)    $\pi$[q] = k
  (8)  return $\pi$
}\end{verbatim}

Nyní si urèíme èasovou sloitost algoritmu. Nejprve vıpoèet prefixové funkce. Základem je,e vnitøní while cyklus se provede nejvıše tolikrát jako cyklus vnìjší. Platí toti, e kadımprùchodem vnitøním cyklem se promìnná 
\texttt{k} sníí, nebo$\pi$[
\texttt{k}]$<$
\texttt{k}. Souèasnì se promìnná 
\texttt{k} mùe zvıšit nejvıšejednou v kadém kroku vnìjšího cyklu (díky øádce (6)). Z toho evidentnì plyne, e poèet prùbìhùvnitøním cyklem je menší roven poètu krokù vnìjšího cyklu. Odtud ji plyne, e èasová sloitostvıpoètu prefixové funkce je \textit{O(m)}.
\\Obdobnou úvahou dojdeme k tomu, e èasová sloitost vyhledávací fáze je \textit{O(n)}. Èasová sloitost celého algoritmu je tedy \textit{O(m+n)}, co je vıraznì lepší ne u naivního algoritmu.

V úvodu celého referátu bylo øeèeno, e KMP algoritmus do jisté míry souvisí s koneènımi automaty. Jak? Je to velice jednoduché. Pøedpokládejme, e máme vzorek 
\texttt{P} délky
\texttt{m}. Definujeme si tedy koneènı automat, kterı bude mít 
\texttt{m+1} stavù. Pøechody mezi jednotlivımi stavy budou postupnì urèené jednotlivımi písmeny vzorku. Tedy napø.pøechod mezi nultım a prvním stavem bude podle písmena 
\texttt{p$_1$}, pøechod meziprvním a druhım stavem podle 
\texttt{p$_2$} atd. Zbylé pøechody (tedy jakési chybové)bude urèovat právì prefixová funkce. Vstupním stavem bude stav 0 a vıstupním stav 
\texttt{m}.Samotné vyhledávání bude realizováno jako práce takového automatu se vstupem, kterı odpovídázadanámu textu. Je zde pouze rozdíl v tom, e pokud se pomocí prefixové funkce vrátím do nìkterého pøedešlého stavu, okamitì zkusím pøes to samé písmeno (které vlastnì zpùsobilo neshodu) pøejít do následujícího stavu, jinak se vracím dále.
\\Uveïme si pøíklad.
\includegraphics{PReferat_files/ObrIII6.gif}

Na obrázku je koneènı automat pro vzorek \textbf{perpetrate}. Nyní si ukáeme, jak budevypadat vıpoèet automatu pro dvì rùzná slova. Vıpoèet je znázornìn jako posloupnost stavù, mezikterımi jsou písmena, pøes která se mezi stavy pøechází.
\\
\\(a) budeme prohledávat text \textbf{perperpetrate}:     0$^p$1$^e$2$^r$3$^p$4$^e$5$^r$2$^r$3$^p$4$^e$5$^t$6$^r$7$^a$8$^t$9$^e$10
\\(b) nyní to bude text \textbf{perpespetrate}:     0$^p$1$^e$2$^r$3$^p$4$^e$5$^s$2$^s$0$^p$1$^e$2$^r$3$^p$4$^e$5$^t$6$^r$7$^a$8$^t$9$^e$10

\hyperlink{obsah}{$>$$>$$>$Obsah}
\\
\\\hypertarget{bm}{

\subsubsection{3. Boyer-Mooreùv algoritmus (BM)}}

V této kapitole si pøedvedeme další chytrı a efektivní algoritmus jeho autory jsou S. Boyer aJ. Strother Moore. Jak bylo øeèeno v úvodu, tento algoritmus se pøíliš zásadnì neliší od naivního algoritmu, kterı jsme si ukázali. Je zde pouze nìkolik odlišností. Abychom si jeukázali, pøedvedeme si ihned, jak Boyer-Mooreùv algoritmus vypadá. Na vstupu je text 
\texttt{T}, vzorek 
\texttt{P} a abeceda $\Sigma$.
\begin{verbatim}

\texttt{
  (1)  n = length(T)
  (2)  m = length(P)
  (3)  $\lambda$ = Last\_Occur\_func(P,m,$\Sigma$)
  (4)  $\gamma$ = Good\_suff\_func(P,m)
  (5)  s = 0
  (6)  while (s $<$= n-m)
  (7)    j = m
  (8)    while (j $>$ 0 \&\& P[j] == T[s+j]) j = j-1
  (9)    if j == 0 
 (10)      then print("Vzorek se nachází na pozici", s+1)
 (11)           s = s+$\gamma$[0]
 (12)      else s = s+max($\gamma$[j], j-$\lambda$[T[s+j]])
}\end{verbatim}

V èem se tedy tento algoritmus podobá a v èem se liší od naivního algoritmu? Podobnost je jakve struktuøe (co zas tak podstatné není) tak ve skuteènosti, e se vzorek opìt porovnávás danım textem a v pøípadì neshody se vzorek posune doprava. Odlišnosti jsou v tom, evzorek se s textem porovnává zprava doleva, tedy odzadu (u naivního algoritmu se porovnáváníprovádí zleva doprava). Pokud narazím na zaèátek vzorku, je jasné e jsem v textu našel jeho vıskyt. Zde je další rozdíl, nebo pøi takovém nálezu neposunu vzorek o jedno místo doprava,ale o nìjakou hodnotu $\gamma$[0]. Pokud narazím na neshodu opìt posunu vzorek, ale posun nemusímít nutnì velikost jedna jako u naivního algoritmu. Ve skuteènosti je tento posun mnohdy mnohemvìtší. Další odlišností je, e v pøípadì naivního algoritmu (a vlastnì i v pøípadì Knuth-Morris-Prattova algoritmu) se zpracoval kadı znak prohledávaného textu aspoò jednou (u naivního algoritmu i mnohokrát). U Boyer-Mooreova algoritmu se díky tomu, e vzorek procházímod konce, a díky tomu, e vzorek v pøípadì neshody posunu mnohdy o více ne jedno písmeno doprava, na nìkteré znaky v prohledávaném textu vùbec nedostane (pøeskoèí se).
\\Aby se tohoto úspìchu dosáhlo, pouívá algoritmus dvì heuristiky (v kódu jsou reprezentoványzatím záhadnımi symboly $\gamma$ a $\lambda$). Jeliko jde o heuristiky dá se oèekávat, ese èasová sloitost v nejhorším pøípadì oproti naivnímu algoritmu pøíliš nezlepší. Naštìstíjsou tyto heuristiky tak efektivní a úspìšné, e v bìné praxi dosahují velmi dobrıch vısledkù.Jak bylo øeèeno vıše, spousta znakù v textu se díky tìmto heuristikám mùe jednoduše pøeskoèitani by byly nìjakım zpùsobem zpracovány. Na následujícím obrázku si ukáeme, jaká ja základnímyšlenka obou heuristik. Jen pro zajímavost v angliètinì se nazıvají "bad-character heuristic"(tedy nìco jako heuristika špatného znaku. Z toho se dá odvodit, e heuristika bude nìjakımzpùsobem souviset se znakem, kterı v textu zpùsobil neshodu.) a "good-suffix heuristic" (tomu v èeštinì odpovídá asi heuristika dobré pøípony. Opìt je zjevné, e bude souviset s pøíponami vzorku).
\includegraphics{PReferat_files/ObrIII7.gif}

Na obrázku (a) vidíme, e hledáme vzorek \textbf{reminiscence} v textu 
\texttt{T}, z kterého vidíme pouze èást. Danı posun 
\texttt{s} je neplatnı, nebo na tøetím znakuod konce došlo k neshodì (pøípomínám, e se vzorek prochází odzadu). Šedì je vyznaèena tzv.dobrá pøípona \textbf{ce}. Je to èást vzorku odzadu, která se shoduje s jistou èástítextu, vzhledem ke kterému je vzorek zarovnán (jak uvidíme pozdìji tato èást se dá velmi jednoduše urèit a z ní se dá spoèítat pøíslušnı posun). Znak \textbf{i}, kterı zpùsobilneshodu (ve vzorku se na stejném místì vyskytuje písmeno \textbf{n}) je ji døíveproklamovanı tzv. špatnı znak.
\\Na obrázku (b) je naèrtnuto, jak si s neshodou poradí "bad-character heuristic". Ta provedeposun vzorku o tolik pozic doprava, aby špatnı znak v textu byl zarovnán k nejpravìjšímu vıskytustejného znaku ve vzorku. Zde je špatnı znak \textbf{i}, a jeliko se \textbf{i}vyskytuje ve vzorku na sedmé pozici od konce, musím vzorek posunout o ètyøi pozice doprava, aby se dosáhlo poadovaného vısledku. U této heuristiky však existují dvì vıjimky. Pokud sešpatnı znak ve vzorku vùbec nevyskytuje, vzorek se posune o takovı poèet míst, aby první písmenovzorku bylo zarovnáno k písmenu, které následuje pøímo po znaku, kterı zpùsobil neshodu.V podstatì jde o nejlepší monı pøípad a je logické, e pokud je v textu znak, kterı se v danémvzorku nenachází nemusím se tou èástí textu zabıvat. Druhou vıjimkou je, pokud je nejpravìjšívıskyt špatného znaku napravo od aktuální pozice, kde byla odhalena neshoda (vzorek by se tedy posouval doleva). V tomto pøípadì neposkytuje heuristika ádnou monost.
\\Na obrázku (c) je zobrazeno chování "good-suffix" heuristiky v pøípadì, e se narazí na neshodu.Tato heuristika provede posun vzorku doprava o nejmenší poèet znakù, kterı zaruèí, e znakyve vzorku, které se po posunu budou nacházet pod dobrou pøíponou bude stejné jako znaky v tétopøíponì, tedy \textbf{ce}. V našem pøíkladu je to posun o tøi pozice doprava.
\\Kdy Boyer-Mooreùv algoritmus narazí na neshodu, dostane v lepším pøípadì dvì doporuèení oddvou heuristik, o kolik je znakù je mono vzorek bezpeènì posunout (v lepším pøípadì, neboheuristika "bad-character" nìkdy doporuèení neposkytne). Algoritmus si tedy logicky vyberevìtší posun (v našem pøíkladì posun vzorku o ètyøi pozice doprava).

Tuto skuteènost (mínìno vybírání a vùbec uití heuristik) je v pseudokódu reflektováno na øádce(12) v pøípadì, e byl nalezen vıskyt vzorku, nebo na øádce (13) v pøípadì, e došlo k neshodì. Zde se vybere vìtší èíslo z 
\texttt{j-$\lambda$[T[s+j]]} (poskytnuto heuristikou "bad-character") a 
\texttt{$\gamma$[j]} (poskytnuto "good-suffix" heuristikou), o které sezvıší posun 
\texttt{s}.
\\Nyní se podíváme, jak jednotlivé heuristiky pøesnì fungují a jak se dají spoèítat posuny, kteréposkytují. U nyní je zøejmé, e posuny závisí pouze na vzorku, pøípadnì na abecedì $\Sigma$.Na prohledávaném textu opìt pøíliš nezáleí.
\\\textbf{Heuristika špatného znaku}

U bylo poznamenáno, e u této heuristiky se vyuívá znalost nejpravìjšího vıskytu znaku ve vzorku, kterı zpùsobil neshodu v textu (
\texttt{T[s+j]}). Z toho se poté odvodí poèetznakù, o kterı se vzorek mùe posunout doprava. Je zøejmé, e v nejlepším pøípadì, kdy dojdek neshodì hned na prvním porovnávaném znaku (tedy posledním znaku vzorku) a tento špatnı znakse ve vzorku nevyskytuje, je moné posunout vzorek doprava o celou jeho délku. Pokud k tomudochází pøi prohledávání opakovanì, porovná se ve skuteènosti pouhı zlomek celkového poètupísmen, které prohledávanı text obsahuje. Heuristika "bad-character" tedy zajišuje velmivırazné urychlení vyhledávacího procesu a to i díky faktu, e porovnávání vzorku s textemse provádí zprava doleva.
\\Jak tedy heuristika ve skuteènosti pracuje? Nebude škodit, kdy k odpovìdi pouijeme trochuformálnìjšího zápisu.
\\Nech pøi porovnávání došlo k neshodì. To znamená, e 
\texttt{P[j]!=T[s+j]} pro nìjaké 
\texttt{j}, pro které platí 
\texttt{1$<$=j$<$=m}. Potom 
\texttt{k} buï nejvìtšíèíslo takové, e 
\texttt{1$<$=k$<$=m} a zároveò 
\texttt{P[k]==T[s+j]}, pokud takové
\texttt{k} existuje. Pokud neexistuje, buï 
\texttt{k=0}. Jedná se tedy o nejpravìjšívıskyt špatného znaku ve vzorku. Vzorek tedy mùeme bezpeènì posunout o 
\texttt{j-k} znakù.V dùkazu tohoto tvrzení se rozlišují tøi moné pøípady podle velikosti 
\texttt{k}, které jsou znázornìny na následujícím obrázku.
\includegraphics{PReferat_files/ObrIII8.gif}

Na obrázku (a) je ilustrován první pøípad, kdy se špatnı znak 
\texttt{T[s+j]} (v našempøíkladì je to písmeno \textbf{h}) ve vzorku na jiném místì vùbec nevyskytuje. Vzorekmùeme tedy bezpeènì posunout o 
\texttt{j} míst ani bychom vynechali monost vıskytuvzorku v textu (na obrázku o 11 pozic). Vzorek se zarovná pod písmeno v textu, které následujepøesnì za znakem, kterı zpùsobil neshodu. Tvrzení v tomto pøípadì platí, nebo 
\texttt{k=0}a vzorek posuneme o 
\texttt{j} pozic, co je pøesnì 
\texttt{j-k} míst.
\\Na dalším obrázku (b) je zobrazen další pøípad, kdy 
\texttt{k$<$j}. Nejpravìjší vıskytšpatného znaku ve vzorku je vlevo od místa 
\texttt{j}, kde došlo k neshodì. Tudí 
\texttt{j-k$>$0} a vzorek mohu o tento poèet míst bezpeènì pøemístit doprava. Vıskytšpatného znaku ve vzorku se potom zarovná ke špatnému znaku v textu. Posun je bezpeènı, protoe
\texttt{k} je index nejblišího znaku, kterı se shoduje se špatnım, vzhledem k posunu. To znamená, e všechny posuny o velikost menší ne 
\texttt{j-k} jsou neplatné a posunprávì o 
\texttt{j-k} je v tuto chvíli platnı (je moné, e se vylouèí hned v dalším kroku).Na obrázku máme situaci, kdy 
\texttt{k=6} a 
\texttt{j=10}, špatnı znak je \textbf{i}. Vzorek tedy posunu o ètyøi pozice a \textbf{i} budou zarovnaná podsebou.
\\ Poslední obrázek (c) znázoròuje i poslední monost postavení špatného znaku ve vzorku, kdy
\texttt{k$>$j}. Potom by platilo, e 
\texttt{j-k$<$0}, co by znamenalo posunutívzorku smìrem doleva (návrat zpátky). Tato monost se v prùbìhu algoritmu automaticky podchytí,nebo druhá heuristika vdy zaruèí posun alespoò o jedno místo a jeliko algoritmus vybírámaximum z obou èísel, vdy se v takovémto pøípadì vybere èíslo poskytnuté heuristikou "good-suffix". V našem pøíkladu je špatnı znak \textbf{e}, 
\texttt{j=10} a 
\texttt{k=12}.

Nyní si uvedeme jednoduchı pseudokód funkce, která heuristiku "bad-character" realizuje. Funkcedostane na vstup vzorek 
\texttt{P}, jeho délku 
\texttt{m} a abecedu $\Sigma$, protoeposun se musí spoèítat pro kadı znak, kterı se mùe vyskytnout jako špatnı.
\begin{verbatim}

\texttt{
Last\_Occur\_func(P,m,$\Sigma$)
  (1)  for kadı znak a z abecedy $\Sigma$
  (2)    $\lambda$[a]=0
  (3)  for j=1 to m
  (4)    $\lambda$[P[j]]=j
  (5)  return $\lambda$
}\end{verbatim}

Funkce vrací pole $\lambda$, kde 
\texttt{$\lambda$[a]} pøedstavuje pozici nejpravìjšího vıskytu znaku 
\texttt{a} ve vzorku a to pro všechny znaky z abecedy $\Sigma$. V pøípadì,e se znak ve vzorku nevyskytuje je hodnota rovna nule. $\lambda$ se nazıvá last-occurence function èili nìco jako funkce posledního vıskytu.
\\Urèení èasové sloitosti je jednoduché. Øádka (2) se provede tolikrát, kolik má abeceda $\Sigma$znakù, tedy |$\Sigma$|-krát. Øádka (4) se provede pøesnì 
\texttt{m}-krát. Èasová sloitostje tudí \textit{O(|$\Sigma$|+m)}.
\\\textbf{Heuristika dobré pøípony}

V tomto odstavci si ukáeme, jak vypoèítat posuny doporuèované druhou heuristikou, heuristikou"good-suffix". Pro tento úèel si definujme relaci 
\texttt{Q\textasciitildeR} pro dva textové øetìzce 
\texttt{Q} a 
\texttt{R}, pro které platí, e buï 
\texttt{Q} je pøíponou
\texttt{R} nebo 
\texttt{R} je pøíponou 
\texttt{Q}. Tato relace neznamená nic jinéhone, e pokud oba øetìzce zarovnáme pod sebe podle pravého okraje, budou se ve znacích podsebou shodovat. Zároveò platí, e 
\texttt{Q\textasciitildeR} právì tehdy, kdy 
\texttt{R\textasciitildeQ}.

Další vztah:
\\Jestlie 
\texttt{Q} je pøíponou 
\texttt{R} a zároveò 
\texttt{S} je pøíponou
\texttt{R}, potom 
\texttt{Q\textasciitildeS}. Slovy øeèeno to znamená, e pokud je 
\texttt{Q}pøíponou 
\texttt{R} a nìjaké 
\texttt{S} je také pøíponou 
\texttt{R}, tak je jasné,e øetìzce 
\texttt{Q} a 
\texttt{S} mají urèitı poèet znakù stejnıch. Tedy buï 
\texttt{Q} je pøíponou 
\texttt{S} nebo 
\texttt{S} je pøíponou 
\texttt{Q}.To je ale 
\texttt{Q\textasciitildeS} podle definice \textasciitilde.

Nech pøi porovnávání došlo k neshodì na 
\texttt{j}-tém místì vzorku (tedy 
\texttt{P[j]!=T[s+j]}), pro nìjaké 
\texttt{j$<$m}. Potom heuristika "good-suffix" øíká,e vzorek mohu bezpeènì posunout o vzdálenost 
\\
\begin{verbatim}
  $\lambda$[j]=m-max\{k: 0$<$=k$<$m \& P[j+1..m]\textasciitildeP$_k$\}
\end{verbatim}Tedy 
\texttt{$\lambda$[j]} je nejmenší vzdálenost, o kterou mùeme vzorek posunout, anibychom zpùsobili nìjakou neshodu dobré pøípony 
\texttt{T[s+j+1..s+m]} vùèi odpovídajícímznakùm novì posunutého vzorku. Tuto situaci si mùeme ukázat na obrázku (b) s pøedchozí kapitoly. K neshodì došlo na tøetím znaku vzorku od konce, tedy 
\texttt{j=3}. Dobrá pøíponaje tedy slovo \textbf{ce}, poslední dvì písmena vzorku \textbf{reminiscence}.Z definice $\lambda$ hledáme nejvìtší 
\texttt{k}, které splòuje, e 
\texttt{P[j+1..m]\textasciitildeP$_k$}. V našem pøípadì je 
\texttt{k=9}, nebo 
\texttt{P[j+1..m]} je slovo \textbf{ce} (dobrá pøípona) a nejdelší pøedpona vzorku 
\texttt{P} konèící \textbf{ce} je slovo \textbf{reminisce}, jeho délka jedevìt. Vzorek tedy mùeme posunout o 
\texttt{m-k=12-9=3} pozice doprava.
\\Ještì poznamenejme, e funkce $\lambda$ je dobøe definována pro všechna 
\texttt{j}, nebo
\texttt{P[j+1..m]\textasciitildeP$_0$} pro všechna 
\texttt{j} (prázdnı øetìzec je v relacise vším). $\lambda$ se nazıvá good-suffix function, v pøekladu funkce dobré pøípony.
\\Jeliko je naše definice této funkce pro úèely vıpoètu na poèítaèi ponìkud nevhodná, provedemenìkolik relativnì jednoduchıch úprav, abychom dostali ekvivalentní definici, ale ve tvaru,v kterém pùjde pøepsat do našeho pseudokódu.
\\Nejprve si ukáeme, e platí vztah 
\texttt{$\lambda$[j]$<$=m-$\pi$[m]} pro všechna 
\texttt{j}, kde $\pi$ je prefixová funkce, kterou jsme pouili u KMP algoritmu. Polome
\texttt{w=$\pi$[m]}. Z definice prefixové funkce máme, e musí platit, e 
\texttt{P$_w$} je pøíponou vzorku 
\texttt{P}. Protoe 
\texttt{P[j+1..m]} je také pøíponou 
\texttt{P}, dostaneme ze vztahu uvedeného vıše, e nutnì 
\texttt{P[j+1..m]\textasciitildeP$_w$}. Podle definice $\lambda$ platí, e 
\texttt{$\lambda$[j]$<$=m-w} (nebo mám 
\texttt{w}, které splòuje poadavky, ale nemusí to bıt maximální takové èíslo, proto je moné, e 
\texttt{$\lambda$[j]} bude menší ne 
\texttt{m-w}). Jeliko máme 
\texttt{w=$\pi$[m]}, plyne odtud rovnou vztah
\texttt{$\lambda$[j]$<$=m-$\pi$[m]} pro všechna 
\texttt{j}, co jsme chtìli dokázat.Díky tomu mùeme naši definici funkce $\lambda$ pøepsat do následující podoby.


\begin{verbatim}
  $\lambda$[j]=m-max\{k: $\pi$[m]$<$=k$<$m \& P[j+1..m]\textasciitildeP$_k$\}
\end{verbatim}

Tuto definici jsme z pøedchozího dostali následovnì.
\begin{verbatim}
  (1)  $\lambda$[j]=m-max\{k: 0$<$=k$<$m \& ...\} $<$= m-$\pi$[m]
  (2)  $\pi$[m] $<$= max\{k: 0$<$=k$<$m \& ...\}
  (3)  k $>$= $\pi$[m]
\end{verbatim}

Úprava mezi (1) a (2) je triviální. Vztah (3) plyne z (2), nebo nejvìtší 
\texttt{k} budevdy vìtší ne 
\texttt{$\pi$[m]}, proto takhle omezené 
\texttt{k} mohu hledat od zaèátku.

Pokraèujme v úpravách naší nové definice $\lambda$. Z podmínky 
\texttt{P[j+1..m]\textasciitildeP$_k$} vyplıvá, e buï 
\texttt{P[j+1..m]} je pøíponou 
\texttt{P$_k$} nebo 
\texttt{P$_k$} je pøíponou 
\texttt{P[j+1..m]}podle definice \textasciitilde. Druhá monost pøímo implikuje, e 
\texttt{P$_k$} je pøíponoucelého vzorku 
\texttt{P} (
\texttt{P$_k$} je pøíponou 
\texttt{P[j+1..m]},co je ale pøípona 
\texttt{P}. Je tedy jasné, e i 
\texttt{P$_k$} je pøíponou
\texttt{P}). Odtud dostaneme vztah, e 
\texttt{k$<$=$\pi$[m]} z definice $\pi$(máme, e 
\texttt{P$_k$} je pøíponou 
\texttt{P} a zároveò 
\texttt{$\pi$[q]=max\{k: k$<$q \& P$_k$ je pøípona P$_q$\}}. Spojením tìchtodvou faktù dojdeme ke vztahu 
\texttt{$\pi$[m]=max\{k: k$<$m \& P$_k$ je pøípona P\}}.Odtud plyne, e 
\texttt{$\pi$[m]$>$=k}, nebo 
\texttt{$\pi$[m]} se rovná maximu, tedypro ostatní 
\texttt{k} je jistì vìtší.). Z této nerovnosti plyne 
\texttt{$\lambda$[j]$>$=m-$\pi$[m]} a to následovnì.
\begin{verbatim}
  k $<$= $\pi$[m]
  m-$\pi$[m] $<$= m-k   pro všechna k
  m-$\pi$[m] $<$= m-max\{k: ...\}=$\lambda$[j]
  m-$\pi$[m] $<$= $\lambda$[j]
\end{verbatim}

Definici $\lambda$ mùeme dále upravit.
\begin{verbatim}
  $\lambda$[j]=m-max(\{$\pi$[m]\} sjednoceno s \{k: $\pi$[m]$<$k$<$m \& P[j+1..m] je pøíponou P$_k$\})
\end{verbatim}

Odtud plyne vıznamná skuteènost, 
\texttt{$\lambda$[j]$>$0} pro všechna 
\texttt{j} (z definice plyne, e buï bude 
\texttt{$\lambda$[j]=m-$\pi$[m]} a to je urèitì kladné(víme, e 
\texttt{$\pi$[m]$<$m}), nebo 
\texttt{$\lambda$[j]=m-k} (k je maximem z druhémnoiny), v tomto pøípadì je ale 
\texttt{$\lambda$[j]} také kladné, nebo 
\texttt{k$<$m}). To je vìc, kterou jsme potøebovali, protoe zaruèí, e BM algoritmusbude posunovat vzorek stále doprava (i v pøípadì, e první heuristika vrátí záporné èíslo).
\\Pokraèujme v naší snaze zjednodušit definici funkce $\lambda$ dále. Pro další úèely si zavedemeobrácenı vzorek 
\texttt{P'} vzorku 
\texttt{P} a tomu odpovídající prefixovou funkci $\pi$'. Potom 
\texttt{P'[i]=P[m-i+1]} pro 
\texttt{i=1,...,m} a 
\texttt{$\pi$'[t]} jenejvìtší 
\texttt{u} takové, e 
\texttt{u$<$t} a zároveò 
\texttt{P'$_u$}je pøíponou 
\texttt{P'$_t$}.
\\Nech 
\texttt{k} je nejvìtší èíslo takové, e 
\texttt{P[j+1..m]} je pøíponou 
\texttt{P$_k$}, potom 
\texttt{$\pi$'[l]=m-j}, kde 
\texttt{l=(m-k)+(m-j)}.
\\Z toho, e 
\texttt{P[j+1..m]} je pøíponou 
\texttt{P$_k$}, plyne 
\texttt{m-j$<$=k} (
\texttt{P[j+1..m]} jako pøípona 
\texttt{P$_k$} nemùebıt delší ne 
\texttt{P$_k$} a délka 
\texttt{P[j+1..m]} je 
\texttt{m-j})a 
\texttt{l$<$=m} (nebo 
\texttt{l=(m-k)+(m-j)} a pøedchozí nerovnost).
\\Také platí, e 
\texttt{j$<$m} a 
\texttt{k$<$=m}, z èeho plyne 
\texttt{l$>$=1}(
\texttt{l=(m-k)+(m-j)}. První závorka je díky první nerovnosti kladná, druhá závorka jedíky druhé nerovnosti nezáporná. Celé je to tedy vìtší nebo rovno jedné.).Jeliko 
\texttt{1$<$=l$<$=m} je funkce $\pi$' dobøe definována.
\\Nyní si dokáeme tvrzení 
\texttt{$\pi$'[l]=m-j}. Jeliko 
\texttt{P[j+1..m]} je pøíponou 
\texttt{P$_k$}, máme také 
\texttt{P'$_m-j$} je pøíponou
\texttt{P'$_l$} (pouhé obrácení a pøeindexování). Odtud dostaneme 
\texttt{$\pi$'[l]$>$=m-j} (nebo 
\texttt{m-j} vyhovuje definici $\pi$', hodnota všakmùe bıt díky maximalizaci i vìtší.). Pro spor pøedpokládejme, e 
\texttt{p$>$m-j}, kde
\texttt{p=$\pi$'[l]}. Podle definice $\pi$' máme, e 
\texttt{P'$_p$} je pøípona
\texttt{P'$_l$}. To se však dá napsat také jako 
\texttt{P'[1..p]=P'[l-p+1..l]}.Pøepisem vzhledem k pùvodnímu vzorku získáme 
\texttt{P[m-p+1..m]=P[m-l+1..m-l+p]}. Pokud teï pouijeme substituci 
\texttt{l=2m-k-j}, dostaneme 
\texttt{P[m-p+1..m]=P[k-m+j+1..k-m+j+p]}. Tedy 
\texttt{P[m-p+1..m]} je pøípona 
\texttt{P$_k-m+j+p$}. Protoe 
\texttt{p$>$m-j}, pak 
\texttt{j+1$>$m-p+1},a tedy 
\texttt{P[j+1..m]} je pøípona 
\texttt{P[m-p+1..m]}. Celkem máme fakt, e
\texttt{P[j+1..m]} je pøípona 
\texttt{P$_k-m+j+p$} (to plyne z tranzitivity"operace suffixování" (
\texttt{A} je pøípona 
\texttt{B} a 
\texttt{B} je pøípona
\texttt{C}, potom 
\texttt{A} je pøíponou 
\texttt{C})).
\\Protoe 
\texttt{p$>$m-j}, máme 
\texttt{k'$>$k}, kde 
\texttt{k'=k-m+j+p}. Jeliko
\texttt{k'} splòuje definici $\pi$' a dokonce 
\texttt{k'$>$k}, docházíme ke sporu s tím, e 
\texttt{k} je nejvìtší èíslo splòující definici $\pi$'.
\\Tedy 
\texttt{p=$\pi$'[l]=m-j} a tvrzení je dokázáno.

Díky tvrzení máme 
\texttt{$\pi$'[l]=m-j}, z toho plyne 
\texttt{j=m-$\pi$'[l]} a dosazenímdo 
\texttt{l=(m-k)+(m-j)} dostaneme 
\texttt{k=m-l+$\pi$'[l]}. Díky tomu mùeme lépe pøepsat definici $\lambda$.
\begin{verbatim}
  $\lambda$[j]=m-max(\{$\pi$[m]\} sjednoceno s \{m-l+$\pi$'[l]: 1$<$=l$<$=m \& j=m-$\pi$'[l]\}) =
      =min(\{m-$\pi$[m]\} sjednoceno s \{l-$\pi$'[l]: 1$<$=l$<$=m \& j=m-$\pi$'[l]\})
\end{verbatim}

Tato definice je ji natolik dobøe formulována, e se dá pøímo pøepsat do pseudokódu. Funkcedostane na vstup vzorek 
\texttt{P} a jeho délku 
\texttt{m}.
\begin{verbatim}

\texttt{
Good\_suff\_func(P,m)
  (1)  $\pi$=Prefix\_func(P)
  (2)  P'=Obrat(P)
  (3)  $\pi$'=Prefix\_func(P')
  (4)  for j = 0 to m
  (5)    $\gamma$[j]=m-$\pi$[m]
  (6)  for l = 1 to m
  (7)    j = m-$\pi$'[l]
  (8)    if $\gamma$[j] $>$ l-$\pi$'[l]
  (9)      then $\gamma$[j] = l-$\pi$'[l])
 (10)  return $\gamma$
}\end{verbatim}

Èasová sloitost této procedury je \textit{O(m)}. Èasová sloitost v nejhorším pøípadì celého BM algoritmu je tedy \textit{O((n-m+1)*m+|$\Sigma$|)} (sloitost obou heuristik dohromady je \textit{O(m+|$\Sigma$|)} a vyhledávací fáze je v podstatì naivní algoritmus). Ve skuteènosti se v bìné praxi dosahuje mnohem lepších vısledkù a tento algoritmus je velmi pouívanı.
\\Postupem èasu se objevilo nìkolik úprav tohoto algoritmu a dosáhlo se lineární sloitosti iv nejhorším pøípadì.

\hyperlink{obsah}{$>$$>$$>$Obsah}
\\
\\\hypertarget{byg}{

\subsubsection{4. Baeza-Yates-Gonnetùv algoritmus (BYG)}}

Nyní si pøedvedeme algoritmus, kterı se od pøedchozích liší u svım pøístupem k vyhledávánív textu. Byl publikován v roce 1992 a autory jsou R. Baeza-Yates a G.H. Gonnet. Narozdíl od dvou algoritmù, které jsme si ji objasnili, a kde se vyhledává pomocíporovnávání znakù ve vzorku a v textu, algoritmus BYG pøišel s ideou vyhledávání pomocí bitovıchmasek. Princip je celkem jednoduchı. I v tomto algoritmu se pouívá pøedpoèítaná tabulka, nyníje to však tabulka bitovıch vektorù pro kadı znak ze vstupní abecedy $\Sigma$. Kadá bitovápozice v daném vektoru pro dané písmeno odpovídá pozici tohoto písmena ve vzorku. Z toho plyne,e kadı vektor musí bıt tak dlouhı jako je danı vzorek. Vektor je posloupnost jednièek, alepokud se znak odpovídající tomuto vektoru vyskytuje na 
\texttt{k}-té pozici ve vzorku, jena 
\texttt{k}-té pozici ve vektoru èíslo nula.
\\Zde existuje nìkolik monıch variant, jak se vektory konstruují. Buï se pozice vektoru èíslujíodleva nebo odprava. Nìkdy jsou vektory nulové a vıskyt znaku ve vzorku je znaèen jednièkou.Nejbìnìjší je však zpùsob, kterı jsme si ukázali a to je èíslování pozic odprava a vıskyt je znaèen nulou. Ukame si na pøíkladu jak taková tabulka vektorù vypadá pro slovo \textbf{states} za pøedpokladu klasické abecedy $\Sigma$
\texttt{=\{a,b,...,z\}}.
\begin{tabular}\textbf{
\texttt{Znak}} & \textbf{
\texttt{Pozice ve vzorku
\\654321}} \\ 

\texttt{a} & 
\texttt{111011} \\ 

\texttt{b} & 
\texttt{111111} \\ 

\texttt{c} & 
\texttt{111111} \\ 

\texttt{d} & 
\texttt{111111} \\ 

\texttt{e} & 
\texttt{101111} \\ 

\texttt{f} & 
\texttt{111111} \\ 

\texttt{...} & 
\texttt{...} \\ 

\texttt{r} & 
\texttt{111111} \\ 

\texttt{s} & 
\texttt{011110} \\ 

\texttt{t} & 
\texttt{110101} \\ 

\texttt{u} & 
\texttt{111111} \\ 

\texttt{...} & 
\texttt{...}
\end{tabular}

Napøíklad písmeno \textbf{s} se ve vzorku vyskytuje na první a šesté poslední pozici, v odpovídajícím vektoru je tudí první a šestı bit nastaven na nulu.
\\Na všechny tyto vektory se mùeme podívat jako na masky, kde nula je transparentní ("prùhledná")a jednièka netransparentní. Tyto masky potom mùeme zarovnat k danému prohledávanému textu.Uveïme si pøíklad. Nech máme text \textbf{misstates}. Potom kdy k písmenùm zarovnámeodpovídající masky dostaneme následující obrázek.
\includegraphics{PReferat_files/ObrIII9.gif}

Na obrázku je kadá maska zarovnána k odpovídajícímu písmenu. To znamená maska pro \textbf{m} je zarovnána k písmenu \textbf{m} v textu, maska pro \textbf{i} je zarovnána k \textbf{i} atd. Jeliko se v textu vzorek \textbf{states} nachází je na obrázku seøazeno šest transparentních bunìk pod sebou.Šedá èára znázoròuje paprsek svìtla, kterım by se daly jednotlivé buòky prosvítit z jedné stranyna druhou.
\\Abychom vidìli rozdíl mezi tím, kdy se vzorek v textu najde a mezi okamikem, kdy dojde k neshodì, ukáeme se další pøíklad. Tentokrát je prohledávanım textem slov \textbf{mistakes}.
\includegraphics{PReferat_files/ObrIII10.gif}

Na obrázku je vidìt, e maska pro písmeno \textbf{k} zamezuje prosvícení blokutransparentních bitù. To znamená, e v textu se vzorek na tomto místì nenachází.
\\Nyní si ukáeme, jak by mohl vypadat kód pro hledání vzorku v textu algoritmem BYG (následujícíkód vyhledá pouze první vıskyt, pro hledání všech vıskytù je potøeba kód èásteènì upravit).Nejprve však nìkolik poznámek. Zmínìné prosvícení bunìk se v programu provádí, ovšem digitálnìpomocí bitovıch operací. Jednotlivé masky se shromaïují v promìnné 
\texttt{work}, jejípoèáteèní hodnota je 
\texttt{-1} (v dvojkovém doplòku jsou to samé jednièky). S kadımnovım znakem v textu se tato promìnná posune o jeden bit doleva (vynásobí se dvìma), coodpovídá odsazování masek na obrázcích. Maska pro novı znak se k promìnné 
\texttt{work}pøidá pomocí operace OR. V kadém cyklu se poté tato promìnná testuje na pøíslušném bituna nulovost (nebo operace OR zachovává nulovost bitù u znakù, které se shodují se vzorkem).Pokud se nula v bitu vyskytuje je vzorek nalezen, v opaèném pøípadì se pokraèuje dále.
\\Program dostává na vstup text 
\texttt{T} a vzorek 
\texttt{P}. Nejprve se musí vytvoøittabulka bitovıch masek a definovat bit, kterı se bude testovat na nulovost (je to vlastnì bits indexem délky vzorku).
\begin{verbatim}

\texttt{
  (1)  n = length(T)
  (2)  m = length(P)
  (3)  masks = Comp\_masks(P, $\Sigma$)
  (4)  testbit = 2\textasciicircumm
  (5)  i = 1
  (6)  found = false
  (7)  while (not found \&\& i $<$ n)
  (8)    while (i $<$ n \&\& T[i] != P[1])  i = i+1
  (9)    work = -1
 (10)    while (work != -1 \&\& not found)
 (11)      work = (work shl 1) or masks[T[i]]
 (12)      if (work and testbit = 0)
 (13)        then found = true
 (14)             print("Vzorek byl nalezen na pozici", i+1-m)
 (15)        else i = i+1
}\end{verbatim}

Cyklus na øádce (8) prochází text do doby ne najde poèáteèní znak vzorku, odtud zaèíná hledatvzorek podle masek. V cyklu (10)-(15) se provádí vlastní èinnost, tedy posouvání a OR-ovánímasky spolu s testem na pøítomnost vzorku.
\\Abychom si lépe ukázali, jak algoritmus funguje (podle kódu, kterı jsme se sestavili a ne podlejakési pøedstavy z pøedchozích obrázkù), probereme další pøíklad. Budeme hledat vzorek \textbf{state} v textu \textbf{misstates}. Program tedy podle øádky (8) projdetext a narazí na znak \textbf{s}, co je poèáteèní písmeno našeho vzorku. Potom sepromìnná 
\texttt{work} nastaví na vıchozí hodnotu -1. Následnì se promìnná posune o jeden bit doleva (nejpravìjší bit bude nula) a pøioruje se maska pro písmeno \textbf{s}.Jeliko tato maska obsahuje nulu na nejpravìjším bitu, operace OR tuto hodnotu zachová.Abychom vidìli, co se bude dít dál, uvedeme si tabulku. Hodnota Posun bude vyjadøovat promìnnou
\texttt{work} posunutou o jeden bit doleva, políèko Maska pøedstavuje masku pro danépísmeno a políèko Vısledek je vısledkem operace OR na pøedchozí dvì hodnoty. Bit, kterı se testuje na nulovost je zvıraznìn.
\begin{tabular}\hline 
\textbf{
\texttt{Vstupní znaky}} & \textbf{
\texttt{Bitové hodnoty}} \\ 
\hline

\texttt{s} & 
\texttt{1111111111111110 Posun
\\1111111111111110 Maska
\\11111111111\textbf{1}1110 Vısledek} \\ 
\hline

\texttt{s} & 
\texttt{1111111111111100 Posun
\\1111111111111110 Maska
\\11111111111\textbf{1}1110 Vısledek} \\ 
\hline

\texttt{t} & 
\texttt{1111111111111100 Posun
\\1111111111110101 Maska
\\11111111111\textbf{1}1101 Vısledek} \\ 
\hline

\texttt{a} & 
\texttt{1111111111111010 Posun
\\1111111111111011 Maska
\\11111111111\textbf{1}1011 Vısledek} \\ 
\hline

\texttt{t} & 
\texttt{1111111111110110 Posun
\\1111111111110101 Maska
\\11111111111\textbf{1}0111 Vısledek} \\ 
\hline

\texttt{e} & 
\texttt{1111111111101110 Posun
\\1111111111101111 Maska
\\11111111111\textbf{0}1111 Vısledek} \\ 
\hline

\end{tabular}

Dále algoritmus nepokraèuje, protoe vzorek byl v tomto okamiku odhalen otestováním pøíslušnéhobitu na nulu. Nyní si ukáeme obdobnou tabulku pro text, kterı vzorek neobsahuje, napø.\textbf{mistakes}.
\begin{tabular}\hline 
\textbf{
\texttt{Vstupní znaky}} & \textbf{
\texttt{Bitové hodnoty}} \\ 
\hline

\texttt{s} & 
\texttt{1111111111111110 Posun
\\1111111111111110 Maska
\\11111111111\textbf{1}1110 Vısledek} \\ 
\hline

\texttt{t} & 
\texttt{1111111111111100 Posun
\\1111111111110101 Maska
\\11111111111\textbf{1}1101 Vısledek} \\ 
\hline

\texttt{a} & 
\texttt{1111111111111010 Posun
\\1111111111111011 Maska
\\11111111111\textbf{1}1011 Vısledek} \\ 
\hline

\texttt{k} & 
\texttt{1111111111110110 Posun
\\1111111111111111 Maska
\\11111111111\textbf{1}1111 Vısledek} \\ 
\hline

\end{tabular}

Program v tuto chvíli skonèí vnitøní cyklus, nebo 
\texttt{work=-1}, co znamená, ebyla nalezena neshoda. Dále by program hledal první znak vzorku (\textbf{s}) v textu.Nyní si ukame jednoduchı kód, kterı pøedpoèítá masky pro všechny znaky abecedy $\Sigma$.Procedura dostane na vstup vzorek 
\texttt{P} a abecedu $\Sigma$.
\begin{verbatim}

\texttt{
  (1)  for kadı znak a z abecedy $\Sigma$ 
  (2)    masks[a] = -1
  (3)  j = 1
  (4)  for i = 1 to m
  (5)    masks[P[i]] = masks[P[i]] and not j
  (6)    j = j shl 1
  (7)  return masks
}\end{verbatim}

Promìnná 
\texttt{j} slouí k vyznaèování nul v pøíslušnıch vektorech. Poèáteèní hodnotouje jednièka a s kadım prùbìhem cyklu se hodnota zdvojnásobí (posun o jeden bit doleva).Napøíklad pokud 
\texttt{j=4}, co je v bitovém zápisu 
\texttt{0000000000000100}. Tím,e operaci AND pouijeme na masku, kterou máme, a na dvojkovı doplòek 
\texttt{j}(
\texttt{1111111111111011}), vyznaèíme nulu na tøetím bitu masky.
\\Èasová sloitost této procedury je \textit{O(m)}, protoe cyklus se vykoná pro kadı znak 
\texttt{m}-krát (cykly jsou sice dva, ale sloitost  \textit{O(2*m)} odpovídá \textit{O(m)}z definice \textit{O}). Èasová sloitost samotného vyhledávání je \textit{O(n)} v nejhorším pøípadì. Celková sloitost je tedy \textit{O(n+m)}.

\hyperlink{obsah}{$>$$>$$>$Obsah}
\\
\\\hypertarget{qs}{

\subsubsection{5. Quicksearch}}

V roce 1990 publikoval èlovìk jménem D.M. Sunday algoritmus Quicksearch, kterı se od pøedchozíchvıznamnì liší ve dvou vìcech. Je rychlejší a mnohem jednodušší. Nìkteré jeho rysy jsou podobnéjako u Boyer-Mooreova algoritmu. U BM algoritmu toti v nejlepším pøípadì pøeskoèíme tolik znakùkolik je délka samotného vzorku. U Quicksearch se, jak uvidíme pozdìji, nejèastìji pøeskakuje
\texttt{m+1} znakù (kde 
\texttt{m} je délka vzorku). Znamená to, e èasová sloitostv prùmìrném pøípadì je ménì ne \textit{O(n)} a blíí se k \textit{O(n/(m+1))}. To je dùleitézvláš pro delší vzorky, kde je urychlení opravdu markantní. U Boyer-Mooreva algoritmu sedíky tomu, e vzorek porovnáváme odzadu, v textu vracíme, co mùe zpùsobit problémy s pamìovımbufferem, které byly popsány v úvodu Knuth-Morris-Prattova algoritmu. Quicksearch nic takovéhonedìlá, take se jeví jako bezproblémovı. Má však jiné nevıhody, které jsou popsané v dalšíkapitole.
\\Myšlenka tohoto algoritmu je opravdu velice jednoduchá. Na zaèátku jako obvykle zarovnáme vzorekk prohledávanému textu. Stejnì jako u naivního algoritmu budeme text a vzorek porovnávat znakpo znaku. Postup se ale liší v pøípadì, e objevíme neshodu mezi jednotlivımi písmeny. V tomtookamiku se podíváme na znak, kterı se nachází v textu pøímo za koncem vzorku (testovı znak).Pokud se tento znak ve vzorku na ádném místì neobjevuje, ádnı posun, kterı by umístil jakékolipísmeno vzorku nad testovı znak, nebude platnı. S klidnım svìdomím tedy mùeme celı vzorek pøemístit a za testovı znak. To pøedstavuje posun o 
\texttt{m+1} znakù, kde 
\texttt{m}je velikost vzorku. Tato vzdálenost je mnohem lepší ne v pøípadì pøedchozích algoritmù (vèetnì BM algoritmu, kde byl posun v tomto pøípadì pouze 
\texttt{m}).
\\Pokud se testovı znak ve vzorku na nìjakém místì nachází (pøípadnì na více místech), posunemevzorek o nejmenší vzdálenost takovou, e se testovı znak bude shodovat se znakem v novì posunutém vzorku, kterı je zarovnán k testovému znaku. Vìtšinou to bude pøedstavovat posuno více ne jeden znak. Dalším porovnáním zjistíme, jestli byl posun spravnı a vzorek se na této pozici ji nachází. Jinak se posuneme stejnım zpùsobem dále. Pro lepší ilustraci, jaktento algoritmus v textu vyhledává, si uvedeme pøíklad. V následujícím textu budeme hledt vıskytvzorku \textbf{problems}.
\includegraphics{PReferat_files/ObrIII11.gif}

Na obrázku (a) je vyobrazena vıchozí situace. Hned první znak textu zpùsobuje neshodu. Testovı znak je písmeno \textbf{h}. Jeliko se takové písmeno ve vzorku nevyskytuje, posunemevzorek o jeho délku zvìtšenou o jedna (tedy o devìt znakù). To znamená, e se vzorek posunea za písmeno \textbf{h}.
\\Situace je ilustrována na obrázku (b). Tentokrát je testovı znak písmeno \textbf{e}, které se ve vzorku vyskytuje. Proto musíme vzorek posunout tak, aby byly dvì \textbf{e}zarovnány pod sebe. Tato vzdálenost musí bıt o jednu vìtší ne je \textbf{e} vzdálenood konce vzorku. Vzorek tedy posuneme o 
\texttt{8-6+1=3} znaky.
\\Na obrázku (c) opìt došlo k neshodì na prvním porovnávaném znaku. Testovı znak je prázdné políèko, které se ve vzorku nevyskytuje. Znovu posuneme vzorek o devìt míst.
\\Následuje situace z obrázku (d). Zde se stejnì jako u naivního algoritmu porovnají tøi znaky(\textbf{pro}). Na ètvrtém písmenu dojde k neshodì. Protoe testovı znak \textbf{i} se ve vzorku nevyskytuje, pøemístíme vzorek a za tento testovı znak, tedyopìt o devìt míst.
\\Obrázek (e). Zde je opìt testovım znakem písmeno \textbf{e} a stejnì jako v pøípadì (b),posuneme vzorek o devìt míst.
\\Na obrázku (f) je zobrazena koneèná situace. Vzorek je nalezen a bylo k tomu potøeba pouhıchpìt posunù a celkem 16 porovnání.

Nyní se u mùeme uvést jak bude algoritmus vypadat zapsán v pseudokódu. Na vstup proceduradostane text 
\texttt{T}, vzorek 
\texttt{P} a abecedu $\Sigma$. Procedura opìt vyhledá pouze první vıskyt pro nalezení všech vıskytù jsou však tøeba jen drobné úpravy. Tabulku posunù 
\texttt{shift} je nutno pøed samotnım vyhledáváním pøedpoèítat.
\begin{verbatim}

\texttt{
  (1)  n = length(T)
  (2)  m = length(P)
  (3)  shift = Comp\_shift(P,$\Sigma$)
  (4)  pat = 1
  (5)  s = 0
  (6)  while (pat $<$= m \&\& pat+s $<$= n)
  (7)    if P[pat] == T[pat+s] 
  (8)      then pat = pat+1
  (9)      else s = s+shift[T[s+m+1]]
 (10)           pat = 1

Comp\_shift(P,$\Sigma$)
  (1)  for kadı znak a z abecedy $\Sigma$
  (2)    shift[a] = m+1
  (3)  for i = 1 to m
  (4)    shift[P[i]] = m-i+1
  (5)  return shift
}\end{verbatim}

Kód je pouze pøepisem faktù, které tu byly vysvìtleny. Snad jen poznámka k funkci Comp\_shift.V prvním cyklu se všem znakùm pøiøadí hodnota maximálního posunu a teprve poté se provádí proznaky, které se ve vzorku vyskytují, pøesnìjší úprava.
\\V nejlepším pøípadì se neshoda objeví pokadé hned u prvního porovnávaného znaku (u prvního myšleno jako prvního po kadém posunu). To znamená, e posun bude pokadé o 
\texttt{m+1} znakù. Èasová sloitost je potom asi \textit{O(n/(m+1))}. Kompletní analıza èasové sloitosti tohoto algoritmu zatím nebyla poskytnuta, ale Sunday tvrdí, e není horší ne \textit{O(n)}.

\hyperlink{obsah}{$>$$>$$>$Obsah}
\\
\\\hypertarget{srov}{

\subsection{IV. Srovnání algoritmù}}

V této kapitole si øekneme vıhody a nevıhody algoritmù, které zde byly popsány. Na jaké úèely se hodí a na jaké ne.
\\První algoritmus, kterému jsme se vìnovali, byl tzv. naivní algoritmus (\hyperlink{naiv}{odkaz}). Myslím, e nemá cenu se tomuto algoritmu vìnovat moc dlouho, nebo svou èasovou sloitostí není pøedurèen k pøíliš velkému pouití. Na druhou stranu pro relativnì krátké texty (øádovì o stovkách maximálnì tisících znacích) a krátké vzorky (20 písmen) je tentoalgoritmus asi dobrou volbou, a to u jenom z dùvodu, e ostatní efektivní algoritmy si pro své potøeby pøedpoèítávají rùzné tabulky, co tento algoritmus nedìlá, a proto se u krátkıch textù jeho pomalost neprojeví a vzhledem ke své jednoduchosti implementace je mnohdy pouíván (implementace v assembleru, pouití v jednoduchıch textovıch editorech apod.). Jeho nevıhodou je, e pøi pouití pro vyhledávání v souborech mùe dojít k problému s pamìovım bufferem, kterı je popsán v úvodu kapitoly vìnované Knuth-Morris-Prattovu algoritmu.
\\Dalším algoritmem, kterı jsme si ukazovali, je právì Knuth-Morris-Prattùv algoritmus (\hyperlink{kmp}{odkaz}). Tento algoritmus odstraòuje hlavní nevıhody naivního algoritmu. Je to pøedevším vícenásobné testování jednoho znaku a vracení se v textu. Díky tomu je vhodnı pro vyhledávání v textovıch souborech, nebo nevznikají problémy s pamìovım bufferem (pravdìpodobnost, e se tento problém vyskytne, je sice malá, ale pøihodit se mùe). Nevıhodou ale je, e se stále porovnávají všechny znaky textu (i kdy jak uvidíme pozdìji, pro jisté speciální úèely je to nezbytné). Algoritmus se hodí pro vyhledávání vzorkù, o kterıchnejsou k dispozici ádné informace, a tedy není jisté, jestli by bylo vıhodnìjší pouít obyèejnı naivní algoritmus.
\\V další kapitole jsme se vìnovali algoritmu Boyera a Moorea (\hyperlink{bm}{odkaz}). Tento algoritmus je asi všeobecnì nejlépe pouitelnı i pøes svou relativní sloitost implementace.Je zvláštì vhodnı pro vzorky vìtší délky a pro relativnì velkou abecedu znakù, kde se obìheuristiky mohou plnì uplatnit. Narozdíl od pøedchozích algoritmù, tento prozkoumá pouzezlomek všech znakù v textu (to se ale v nìkterıch pøípadech mùe nevyplatit). Bohuel díkyzpìtnému porovnávání vzorku s textem mùe dojít stejnì jako u naivního algoritmu k problémùms pamìovım bufferem, kterı vyaduje další reii vıpoètu. I pøes nepøíliš dobrou èasovou sloitost je v prùmìru velmi dobrı.
\\Následuje algoritmus Baeza-Yates-Gonnet (\hyperlink{byg}{odkaz}). Tento algoritmus je velmispecifickı, a proto jsou s ním spjatá i jistá omezení co do implementace. Prvním omezením jepoadavek na schopnost programovacího jazyka (a poèítaèe) provádìt bitové operace OR, AND a bitovı posun, na èíslech typu 
\texttt{integer}. Druhım a po pravdì øeèeno asi drastiètìjším omezením je délka bitovıch masek, které se v algoritmu pouívají. Tyto masky musí mít stejnou délku jako danı vzorek. Dnešní poèítaèe poèítají vše buï v 32-bitové nebo v 64-bitové aritmetice, co je omezení pro kompilátory programovacích jazykù a tím i pro délku bitové masky. Proto v pøípadì, e chceme hledat vzorek delší ne 32 (potamo 64) bitù, není tento algoritmus i pøes svou rychlost tou správnou volbou. Na druhou stranu, pokud chceme sestrojit algoritmus, kterı nebude case-sensitive (tedy nebude rozlišovat velikost písmen), není problém upravitBaeza-Yates-Gonnetùv algoritmus tak, aby tento poadavek bez problémù øešil. Staèí pouze vyrobit masky zvláš pro velká a malá písmena a trochu upravit vyhledávací èást.
\\Tím se dostáváme k poslednímu algoritmu, kterı zde byl popsán, Quicksearch (\hyperlink{qs}{odkaz}). Nejdøíve dvì fakta. Za prvé tento algoritmus se stejnì jako KMP a BYG v textu nevrací zpìt. Za druhé, stejnì jako Boyer-Mooreùv algoritmus i tento pøeskakuje velké mnoství neporovnanıch znakù. Jak bylo øeèeno, je tato skuteènost vıhodou co do urychlení algoritmu, ale ve speciálních pøípadech není toto pøeskakování ádoucí. Takovım pøíkladem mùe bıt situace, kdy pøi kadém nalezení vzorku v textu chceme, aby program nahlásil èíslo øádky, kde se vzorek vyskytuje. V pøípadì, kdy program poèítá kadı znak pro novou øádku a tento znak se posunutím vzorku o nìkolik pozic pøeskoèí, dochází pøi nahlášení vıskytu vzorku ke zkreslení informace o èísle øádky. Proto je pøi vıbìru algoritmu nutné uvaovat, k èemu bude slouit.Testy ukázaly (na textech o délce pøiblinì 200000 znakù), e Quicksearch si velmi dobøe poèíná v situacích, kdy je vzorek relativnì delší. Pøi nejèastìjších délkách vzorkù (od šesti do osmipísmen) porovná algoritmus pouze pøiblinì jednu šestinu všech znakù. Záleí však i na tom, jakvzorek vypadá. Existují dvì upravené verze (\emph{maximal shift algorithm} a \emph{optimal shiftalgorithm}), které dosahují o pìt procent lepších vısledkù ne základní algoritmus. Vzhledemk tomu, e pøed vlastním vyhledáváním pøedpoèítávají spoustu rùznıch vìcí, jsou ale vhodné pouze pro texty délky øádovì o stotísících znacích.

\hyperlink{obsah}{$>$$>$$>$Obsah}
\\
\\\hypertarget{zav}{

\subsection{V. Závìr}}

V tomto dokumentu jsme popsali nìkolik algoritmù zabıvajících se vyhledáváním vzorkù v textu.Všechny mají jednu vlastnost spoleènou, vyhledávají jeden vzorek v textu. Samozøejmì existujíi algoritmy, které vyhledávají celé mnoiny vzorkù (algoritmus Aho-Corasickové, algoritmusCommentz-Walterové) i mnoiny zadané pomocí regulárních vırazù (B-algoritmus). I pøesto jsoutyto algoritmy velice uiteèné a svou vzájemnou rozdílností je spektrum jejich pouitelnostipomìrnì široké. Dále jsme si uvedli vıhody a nevıhody jednotlivıch algoritmù, k èemu sehodí a k èemu. U kadého je vedle podrobného vysvìtlení i pseudokód, podle kterého by nemìlbıt problém danı algoritmus naprogramovat.
\\Tento dokument je tedy jakısi úvod do problematiky vyhledávání v textu, nebo tato úlohaje velice rozsáhlá a zasahuje do mnoha oborù teoretické informatiky.

\hyperlink{obsah}{$>$$>$$>$Obsah}
\\
\\\hypertarget{ref}{

\subsection{VI. Literatura}}

Zde jsou uvedeny pouité materiály.
\begin{itemize}
	\item T.H.Cormen, C.E.Leiserson, R.L.Rivest: Introduction to Algorithms, MIT Press 1990, kapitola34 - String matching 
	\item Ivana Vovsová: Vyhledávání vzorkù v textu, diplomová práce, MFF 1994 
	\item String Searching, èlánek z neznámé knihy od neznámého autora 
	\item A. Koubková, J. Pavelka: Úvod do teoretické informatiky, MFFPress 1998
\end{itemize}

\hyperlink{obsah}{$>$$>$$>$Obsah}

\end{document}
